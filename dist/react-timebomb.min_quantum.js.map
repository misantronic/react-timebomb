{"version":3,"sources":["src/utils.ts","src/value.tsx"],"names":["moment_1","$fsx","r","momentImport","moment","default","dateFormat","date","format","isArray","map","getFormatType","test","exports","formatSplitExpr","validateDate","dates","instance","isValid","toDate","undefined","filter","d","Boolean","length","formatIsActualNumber","validateFormatGroup","input","isFinite","int","parseInt","char","String","strLen","startsWith","ALLOWED_CHARS","startOfDay","newDate","Date","setHours","addDays","num","add","addMonths","subtractMonths","subtract","Array","val","stringFromCharCode","keyCode","charCode","Math","floor","fromCharCode","includes","formatNumber","number","splitDate","split","group","joinDates","parts","strParts","part","HTMLElement","innerText","splittedFormat","join","spaceFormat","momentDate","parsingFlags","overflow","parsedDateParts","clearSelection","sel","getSelection","empty","removeAllRanges","selectElement","el","caret","range","document","createRange","selectNodeContents","start","end","setStart","setEnd","addRange","getWeekOfYear","isoWeek","startOfWeek","startOf","endOfWeek","endOf","endOfDay","subtractDays","manipulateDate","isSame","isBefore","inp","isAfter","dateA","isEnabled","isSameOrAfter","minDate","context","getAttribute","attr","isDateFormat","isTimeFormat","a","b","getTime","value","formatType","replaceSpaceWithNbsp","str","replace","keys","ARROW_UP","ARROW_RIGHT","ARROW_DOWN","ARROW_LEFT","ENTER","TAB","ESC","BACKSPACE","DELETE","SPACE","SHIFT","DOT","COMMA","React","styled_components_1","utils_1","button_1","arrow_button_1","Flex","div","Container","props","disabled","Input","span","ClearButton","SmallButton","Placeholder","Icon","icon","META_KEYS","FORBIDDEN_KEYS","Value","PureComponent","[object Object]","super","this","inputs","onFocus","timeout","e","clearTimeout","currentTarget","setTimeout","state","allSelected","formatGroup","onChangeFormatGroup","onSearchRef","bind","onKeyDown","onKeyUp","onClick","onDblClick","onBlur","onChange","onClear","onToggle","formatGroups","reduce","memo","prevChar","substr","focused","querySelector","iconClass","showTime","showDate","prevProps","open","mode","allowValidation","some","forEach","i","focus","find","setState","forceUpdate","placeholder","ArrowButtonComp","arrowButtonComponent","ArrowButton","showPlaceholder","showClearer","timeOnly","createElement","data-role","className","renderValue","tabIndex","mobile","contentEditable","g","separator","data-react-timebomb-selectable","data-placeholder","data-separator","key","data-group","ref","onDoubleClick","push","onChangeValueText","nextSibling","previousSibling","numericFormat","hasSelection","focusOffset","baseOffset","numericValue","preventDefault","HTMLSpanElement","isArrowUp","isNaN","direction","shiftKey","dateParts","nextValue","valid","groupValue","metaKey","ctrlKey","firstInput","validatedChar","onSubmit","blur","parentNode","onAllSelect","target","dataGroup","filledValue","fillZero","stopPropagation"],"mappings":"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","sourcesContent":["// @ts-ignore\nimport momentDefaultImport from 'moment';\nimport * as momentImport from 'moment';\nimport { ReactTimebombDate, FormatType } from './typings';\n\nconst moment: typeof momentImport = momentDefaultImport || momentImport;\n\nexport const formatSplitExpr = /[.|:|\\-|\\\\|_|\\s]/;\n\nexport function dateFormat(date: Date, format: string): string;\nexport function dateFormat(date: Date[], format: string): string[];\nexport function dateFormat(\n    date: Date | Date[],\n    format: string\n): string | string[];\nexport function dateFormat(\n    date: Date | Date[],\n    format: string\n): string | string[] {\n    if (isArray(date)) {\n        return date.map(date => moment(date).format(format));\n    } else {\n        return moment(date).format(format);\n    }\n}\n\nexport function validateDate(\n    date: string | string[] | undefined,\n    format: string\n): ReactTimebombDate {\n    if (isArray(date)) {\n        const dates = date\n            .map(date => {\n                const instance = moment(date, format, true);\n\n                return instance.isValid() ? instance.toDate() : undefined;\n            })\n            .filter(d => Boolean(d)) as Date[];\n\n        return dates.length === 0 ? undefined : dates;\n    } else {\n        const instance = moment(date, format, true);\n\n        return instance.isValid() ? instance.toDate() : undefined;\n    }\n}\n\nexport function getFormatType(format: string): FormatType | undefined {\n    if (/^D/.test(format)) {\n        return 'day';\n    }\n\n    if (/^M/.test(format)) {\n        return 'month';\n    }\n\n    if (/^Y/.test(format)) {\n        return 'year';\n    }\n\n    if (/^H/.test(format)) {\n        return 'hour';\n    }\n\n    if (/^m/.test(format)) {\n        return 'minute';\n    }\n\n    if (/^s/.test(format)) {\n        return 'second';\n    }\n\n    return undefined;\n}\n\nexport function formatIsActualNumber(format: string) {\n    // day / year\n    if (/D|Y/.test(format)) {\n        return true;\n    }\n\n    // month\n    if (format === 'M' || format === 'MM') {\n        return true;\n    }\n\n    return false;\n}\n\n/** @return returns a string with transformed value, true for valid input or false for invalid input */\nexport function validateFormatGroup(\n    input: string | number,\n    format: string\n): boolean | string {\n    if (isFinite(input as any)) {\n        const int = typeof input === 'string' ? parseInt(input, 10) : input;\n        const char = String(input);\n        const strLen = char.length;\n        const type = getFormatType(format);\n\n        switch (type) {\n            case 'day':\n                if (strLen === 1) {\n                    if (int >= 0 && int <= 3) {\n                        return true;\n                    } else {\n                        return `0${input}`;\n                    }\n                }\n\n                if (strLen === 2 && int >= 1 && int <= 31) {\n                    return true;\n                }\n                break;\n            case 'month':\n                if (strLen === 1) {\n                    if (int === 0 || int === 1) {\n                        return true;\n                    } else {\n                        return `0${input}`;\n                    }\n                }\n\n                if (strLen === 2 && int >= 0 && int <= 12) {\n                    return true;\n                }\n                break;\n            case 'year':\n                if (strLen === 1 && (int === 1 || int === 2)) {\n                    return true;\n                }\n\n                if (\n                    strLen >= 2 &&\n                    (char.startsWith('19') || char.startsWith('20'))\n                ) {\n                    return true;\n                }\n                break;\n            case 'hour':\n                if (strLen === 1) {\n                    if (int >= 0 && int <= 2) {\n                        return true;\n                    } else {\n                        return `0${input}`;\n                    }\n                }\n\n                if (strLen >= 2 && int >= 0 && int <= 24) {\n                    return true;\n                }\n                break;\n            case 'minute':\n            case 'second':\n                if (strLen === 1) {\n                    if (int >= 0 && int <= 5) {\n                        return true;\n                    } else {\n                        return `0${input}`;\n                    }\n                }\n\n                if (strLen >= 2 && int >= 0 && int <= 59) {\n                    return true;\n                }\n                break;\n        }\n    }\n\n    return false;\n}\n\nconst ALLOWED_CHARS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n\nexport function stringFromCharCode(keyCode: number): string {\n    const charCode = keyCode - 48 * Math.floor(keyCode / 48);\n    const char = String.fromCharCode(96 <= keyCode ? charCode : keyCode);\n\n    if (ALLOWED_CHARS.includes(char)) {\n        return char;\n    }\n\n    return '';\n}\n\nexport function formatNumber(number: Number): string {\n    if (number <= 1) {\n        return '01';\n    }\n\n    if (number <= 9) {\n        return `0${number}`;\n    }\n\n    return String(number);\n}\n\nexport function splitDate(date: Date, format: string): string[] {\n    const formattedDate = dateFormat(date, format);\n\n    return formattedDate\n        .split(formatSplitExpr)\n        .filter(group => group && formatSplitExpr.test(group) === false);\n}\n\nexport function joinDates(\n    parts: (string | HTMLElement)[],\n    format: string\n): string {\n    const strParts = parts\n        .map(part => (part instanceof HTMLElement ? part.innerText : part))\n        .filter(val => val);\n    const splittedFormat = format.split(formatSplitExpr);\n\n    if (strParts.length !== splittedFormat.length) {\n        return '';\n    }\n\n    const date = strParts.join(' ');\n    const spaceFormat = splittedFormat.join(' ');\n    const momentDate = moment(date, spaceFormat);\n    const parsingFlags = momentDate.parsingFlags();\n\n    if (parsingFlags.overflow === 2) {\n        return moment(\n            // @ts-ignore\n            new Date(...parsingFlags.parsedDateParts)\n        ).format(format);\n    }\n\n    return momentDate.format(format);\n}\n\nexport function clearSelection(): void {\n    const sel = getSelection();\n\n    if (sel.empty) {\n        // Chrome\n        sel.empty();\n    } else if (sel.removeAllRanges) {\n        // Firefox\n        sel.removeAllRanges();\n    }\n}\n\nexport function selectElement(\n    el: HTMLElement | undefined,\n    caret?: number[]\n): void {\n    if (el) {\n        const range = document.createRange();\n        const sel = getSelection();\n\n        if (caret === undefined) {\n            range.selectNodeContents(el);\n        } else {\n            const [start, end] = caret;\n\n            range.setStart(el, start);\n            range.setEnd(el, end);\n        }\n\n        sel.removeAllRanges();\n        sel.addRange(range);\n    }\n}\n\nexport function getWeekOfYear(date: Date): number {\n    return moment(date).isoWeek();\n}\n\nexport function startOfWeek(date: Date): Date {\n    return moment(date)\n        .startOf('isoWeek')\n        .toDate();\n}\n\nexport function endOfWeek(date: Date): Date {\n    return moment(date)\n        .endOf('isoWeek')\n        .toDate();\n}\n\nexport function startOfDay(date: Date): Date {\n    const newDate = new Date(date);\n\n    newDate.setHours(0, 0, 0, 0);\n\n    return newDate;\n}\n\nexport function endOfDay(date: Date): Date {\n    const newDate = new Date(date);\n\n    newDate.setHours(23, 59, 59, 999);\n\n    return newDate;\n}\n\nexport function addDays(date: Date, num: number): Date {\n    return moment(date)\n        .add(num, 'days')\n        .toDate();\n}\n\nexport function addMonths(date: Date, num: number): Date {\n    return moment(date)\n        .add(num, 'months')\n        .toDate();\n}\n\nexport function addYears(date: Date, num: number): Date {\n    return moment(date)\n        .add(num, 'years')\n        .toDate();\n}\n\nexport function addHours(date: Date, num: number): Date {\n    return moment(date)\n        .add(num, 'hours')\n        .toDate();\n}\n\nexport function addMinutes(date: Date, num: number): Date {\n    return moment(date)\n        .add(num, 'minutes')\n        .toDate();\n}\n\nexport function addSeconds(date: Date, num: number): Date {\n    return moment(date)\n        .add(num, 'seconds')\n        .toDate();\n}\n\nexport function subtractSeconds(date: Date, num: number): Date {\n    return moment(date)\n        .subtract(num, 'seconds')\n        .toDate();\n}\n\nexport function subtractMinutes(date: Date, num: number): Date {\n    return moment(date)\n        .subtract(num, 'minutes')\n        .toDate();\n}\n\nexport function subtractHours(date: Date, num: number): Date {\n    return moment(date)\n        .subtract(num, 'hours')\n        .toDate();\n}\n\nexport function subtractDays(date: Date, num: number): Date {\n    return moment(date)\n        .subtract(num, 'days')\n        .toDate();\n}\n\nexport function subtractMonths(date: Date, num: number): Date {\n    return moment(date)\n        .subtract(num, 'months')\n        .toDate();\n}\n\nexport function subtractYears(date: Date, num: number): Date {\n    return moment(date)\n        .subtract(num, 'years')\n        .toDate();\n}\n\nexport function manipulateDate(\n    date: Date,\n    formatType: FormatType,\n    direction: 'add' | 'subtract',\n    shift = false\n): Date {\n    switch (formatType) {\n        case 'day':\n            if (direction === 'add') return addDays(date, 1);\n            if (direction === 'subtract') return subtractDays(date, 1);\n            break;\n        case 'month':\n            if (direction === 'add') return addMonths(date, 1);\n            if (direction === 'subtract') return subtractMonths(date, 1);\n            break;\n        case 'year':\n            if (direction === 'add') return addYears(date, 1);\n            if (direction === 'subtract') return subtractYears(date, 1);\n            break;\n        case 'hour':\n            if (direction === 'add') return addHours(date, shift ? 10 : 1);\n            if (direction === 'subtract')\n                return subtractHours(date, shift ? 10 : 1);\n            break;\n        case 'minute':\n            if (direction === 'add') return addMinutes(date, shift ? 10 : 1);\n            if (direction === 'subtract')\n                return subtractMinutes(date, shift ? 10 : 1);\n            break;\n        case 'second':\n            if (direction === 'add') return addSeconds(date, shift ? 10 : 1);\n            if (direction === 'subtract')\n                return subtractSeconds(date, shift ? 10 : 1);\n            break;\n    }\n\n    return new Date();\n}\n\nexport function startOfMonth(date: Date): Date {\n    const newDate = new Date(date);\n\n    newDate.setDate(1);\n    newDate.setHours(0, 0, 0, 0);\n\n    return newDate;\n}\n\nexport function endOfMonth(date: Date): Date {\n    return new Date(date.getFullYear(), date.getMonth() + 1, 0);\n}\n\nexport function isUndefined(val): val is undefined {\n    return val === null || val === undefined;\n}\n\nexport function setDate(date: Date, hour: number, min?: number): Date {\n    const newDate = new Date(date);\n\n    newDate.setHours(hour, min);\n\n    return newDate;\n}\n\nexport function isToday(date: Date): boolean {\n    return moment(date).isSame(new Date(), 'day');\n}\n\nexport function isBefore(date: Date, inp: Date) {\n    return moment(date).isBefore(inp, 'day');\n}\n\nexport function isAfter(date: Date, inp: Date) {\n    return moment(date).isAfter(inp, 'day');\n}\n\nexport function dateEqual(\n    dateA?: ReactTimebombDate,\n    dateB?: ReactTimebombDate,\n    considerTime = false\n) {\n    if (!dateA || !dateB) {\n        return false;\n    }\n\n    if (considerTime) {\n        if (isArray(dateA)) {\n            dateA = dateA.map(startOfDay);\n        } else {\n            dateA = startOfDay(dateA);\n        }\n\n        if (isArray(dateB)) {\n            dateB = dateB.map(startOfDay);\n        } else {\n            dateB = startOfDay(dateB);\n        }\n    }\n\n    if (isArray(dateA) && isArray(dateB)) {\n        return dateA.every((date, i) => {\n            const dBi = dateB![i];\n\n            if (date && dBi) {\n                return date.getTime() === dBi.getTime();\n            }\n\n            return false;\n        });\n    } else if (isArray(dateA) && dateB instanceof Date) {\n        return dateA.some(d => d.getTime() === (dateB as Date).getTime());\n    } else if (isArray(dateB) && dateA instanceof Date) {\n        return dateB.some(d => d.getTime() === (dateA as Date).getTime());\n    } else if (!isArray(dateA) && !isArray(dateB)) {\n        return dateA.getTime() === dateB.getTime();\n    }\n\n    return false;\n}\n\nexport function getMonthNames(short?: boolean): string[] {\n    if (short) {\n        return moment.monthsShort();\n    }\n\n    return moment.months();\n}\n\nexport function getWeekdayNames() {\n    return moment.weekdaysShort();\n}\n\nexport function isEnabled(\n    context: 'year' | 'month' | 'day',\n    date: Date,\n    { minDate, maxDate }: { minDate?: Date; maxDate?: Date }\n): boolean {\n    if (!minDate && !maxDate) {\n        return true;\n    }\n\n    if (minDate && !maxDate) {\n        return moment(date).isSameOrAfter(minDate, context);\n    }\n\n    if (!minDate && maxDate) {\n        return moment(date).isSameOrBefore(maxDate, context);\n    }\n\n    return moment(date).isBetween(minDate, maxDate, context, '[]');\n}\n\nexport function getAttribute(input: Element, attr: string): string {\n    return input.getAttribute(attr)!;\n}\n\nexport function isDateFormat(format: string) {\n    return Boolean(/D|M|Y/.test(format));\n}\n\nexport function isTimeFormat(format: string) {\n    return Boolean(/H|h|m|k|a|S|s/.test(format));\n}\n\nexport function sortDates(a: Date, b: Date) {\n    return a.getTime() - b.getTime();\n}\n\nexport function isArray(val: any): val is any[] {\n    return Array.isArray(val);\n}\n\nexport function fillZero(value: string | number, formatType: FormatType) {\n    value = String(value);\n\n    switch (formatType) {\n        case 'day':\n            if (value === '1' || value === '2' || value === '3') {\n                return `0${value}`;\n            }\n            break;\n        case 'month':\n            if (value === '1') {\n                return `0${value}`;\n            }\n            break;\n    }\n\n    return undefined;\n}\n\nexport function replaceSpaceWithNbsp(str?: string) {\n    if (!str) {\n        return str;\n    }\n\n    return str.replace(' ', ' ');\n}\n\nexport const keys = {\n    ARROW_UP: 38,\n    ARROW_RIGHT: 39,\n    ARROW_DOWN: 40,\n    ARROW_LEFT: 37,\n    ENTER: 13,\n    TAB: 9,\n    ESC: 27,\n    BACKSPACE: 8,\n    DELETE: 46,\n    SPACE: 32,\n    SHIFT: 16,\n    DOT: 190,\n    COMMA: 188\n};\n","import * as React from 'react';\nimport styled from 'styled-components';\nimport {\n    keys,\n    formatNumber,\n    splitDate,\n    joinDates,\n    stringFromCharCode,\n    validateFormatGroup,\n    getAttribute,\n    getFormatType,\n    manipulateDate,\n    isEnabled,\n    selectElement,\n    fillZero,\n    clearSelection,\n    formatSplitExpr,\n    formatIsActualNumber,\n    replaceSpaceWithNbsp\n} from './utils';\nimport { ReactTimebombProps, ReactTimebombState } from './typings';\nimport { SmallButton } from './button';\nimport { ArrowButton } from './arrow-button';\n\nexport interface ValueProps {\n    open?: boolean;\n    value?: Date;\n    format: string;\n    placeholder: ReactTimebombProps['placeholder'];\n    minDate: ReactTimebombProps['minDate'];\n    maxDate: ReactTimebombProps['maxDate'];\n    showDate: ReactTimebombState['showDate'];\n    showTime: ReactTimebombState['showTime'];\n    mode: ReactTimebombState['mode'];\n    allowValidation: ReactTimebombState['allowValidation'];\n    arrowButtonComponent: ReactTimebombProps['arrowButtonComponent'];\n    disabled: ReactTimebombProps['disabled'];\n    mobile: ReactTimebombProps['mobile'];\n    onToggle(): void;\n    onChangeValueText(valueText?: string, commit?: boolean): void;\n    onChangeFormatGroup(formatGroup: string): void;\n    onAllSelect(): void;\n    onSubmit(): void;\n    onClear(): void;\n}\n\ninterface ValueState {\n    allSelected?: boolean;\n}\n\ninterface InputProps {\n    disabled?: boolean;\n}\n\nexport const Flex = styled.div`\n    display: flex;\n    align-items: center;\n    white-space: nowrap;\n    position: relative;\n`;\n\nexport const Container = styled(Flex)`\n    justify-content: space-between;\n    align-items: center;\n    padding: 5px 10px;\n    border: 1px solid #ccc;\n    cursor: ${(props: { disabled?: boolean }) =>\n        props.disabled ? 'not-allowed' : 'pointer'};\n    width: 100%;\n    height: 100%;\n    box-sizing: border-box;\n`;\n\nconst Input = styled.span`\n    padding: 2px 0 2px 0;\n    min-width: 1px;\n    cursor: ${(props: InputProps) => (props.disabled ? 'not-allowed' : 'text')};\n    pointer-events: ${(props: InputProps) =>\n        props.disabled ? 'none' : 'auto'};\n\n    &:focus {\n        outline: none;\n    }\n\n    &:last-of-type {\n        padding: 2px 10px 2px 0;\n    }\n\n    &:not(:last-of-type):after {\n        content: attr(data-separator);\n        min-width: 4px;\n        display: inline-block;\n    }\n\n    &:empty:before {\n        content: attr(data-placeholder);\n        color: #aaa;\n    }\n\n    &:empty:not(:last-of-type):after {\n        color: #aaa;\n    }\n\n    &:not([contenteditable='true']) {\n        user-select: none;\n    }\n`;\n\nexport const ClearButton = styled(SmallButton)`\n    font-size: 18px;\n`;\n\nexport const Placeholder = styled.span`\n    color: #aaa;\n    user-select: none;\n`;\n\nexport const Icon = styled.span`\n    margin-right: 5px;\n    user-select: none;\n\n    &:after {\n        content: '${(props: { icon: string }) => props.icon}';\n    }\n`;\n\nconst META_KEYS = [keys.BACKSPACE, keys.DELETE, keys.TAB];\n\nconst FORBIDDEN_KEYS = [\n    keys.SHIFT,\n    keys.ARROW_LEFT,\n    keys.ARROW_RIGHT,\n    keys.ARROW_UP,\n    keys.ARROW_DOWN,\n    keys.TAB\n];\n\nexport class Value extends React.PureComponent<ValueProps, ValueState> {\n    private inputs: HTMLSpanElement[] = [];\n\n    private get formatGroups(): string[] {\n        return this.props.format.split('').reduce(\n            (memo, char) => {\n                const prevChar = memo[memo.length - 1];\n\n                if (\n                    (prevChar && char === prevChar.substr(0, 1)) ||\n                    (formatSplitExpr.test(prevChar) &&\n                        formatSplitExpr.test(char))\n                ) {\n                    memo[memo.length - 1] += char;\n                } else {\n                    memo = [...memo, char];\n                }\n\n                return memo;\n            },\n            [] as string[]\n        );\n    }\n\n    private get focused(): HTMLElement | null {\n        return document.querySelector(':focus');\n    }\n\n    private get iconClass(): 'time' | 'calendar' {\n        const { showTime, showDate } = this.props;\n\n        if (!showDate && showTime) {\n            return 'time';\n        }\n\n        return 'calendar';\n    }\n\n    private get icon() {\n        switch (this.iconClass) {\n            case 'calendar':\n                return '📅';\n            case 'time':\n                return '⏱';\n        }\n    }\n\n    constructor(props: ValueProps) {\n        super(props);\n\n        this.state = {};\n\n        this.onSearchRef = this.onSearchRef.bind(this);\n        this.onKeyDown = this.onKeyDown.bind(this);\n        this.onKeyUp = this.onKeyUp.bind(this);\n        this.onFocus = this.onFocus.bind(this);\n        this.onClick = this.onClick.bind(this);\n        this.onDblClick = this.onDblClick.bind(this);\n        this.onBlur = this.onBlur.bind(this);\n        this.onChange = this.onChange.bind(this);\n        this.onClear = this.onClear.bind(this);\n        this.onToggle = this.onToggle.bind(this);\n    }\n\n    public componentDidUpdate(prevProps: ValueProps): void {\n        setTimeout(() => {\n            const { open, value, format, mode, allowValidation } = this.props;\n            const hasFocus = this.inputs.some(inp => inp === this.focused);\n\n            if (!hasFocus) {\n                if (open) {\n                    if (prevProps.value !== value && value) {\n                        const parts = splitDate(value, format);\n                        const input = this.inputs[0];\n\n                        this.inputs.forEach(\n                            (input, i) => (input.innerText = parts[i])\n                        );\n\n                        if (input) {\n                            input.focus();\n                        }\n                    }\n\n                    if (!prevProps.open || value !== prevProps.value) {\n                        const [input] = this.inputs;\n\n                        if (input) {\n                            selectElement(input);\n                        }\n                    }\n                }\n            }\n\n            if (open && prevProps.mode !== mode && !this.state.allSelected) {\n                const input = this.inputs.find(el => {\n                    const format = getAttribute(el, 'data-group');\n                    const type = getFormatType(format);\n\n                    return type === mode;\n                });\n\n                selectElement(input);\n            }\n\n            if (!open && value) {\n                const parts = splitDate(value, format);\n\n                this.inputs.forEach((input, i) => (input.innerText = parts[i]));\n            }\n\n            if (open && prevProps.value && !value && !allowValidation) {\n                this.inputs.forEach(input => (input.innerText = ''));\n            }\n\n            if (!open) {\n                this.setState({ allSelected: false });\n            }\n        }, 16);\n    }\n\n    public componentDidMount() {\n        if (this.props.value) {\n            this.forceUpdate();\n        }\n    }\n\n    public render(): React.ReactNode {\n        const {\n            placeholder,\n            value,\n            showDate,\n            showTime,\n            disabled,\n            open\n        } = this.props;\n        const ArrowButtonComp = this.props.arrowButtonComponent || ArrowButton;\n        const showPlaceholder = placeholder && !open;\n        const showClearer = value && !disabled;\n        const timeOnly = showTime && !showDate;\n\n        return (\n            <Container\n                data-role=\"value\"\n                className=\"react-slct-value react-timebomb-value\"\n                disabled={disabled}\n                onClick={this.onToggle}\n            >\n                <Flex>\n                    <Icon\n                        icon={this.icon}\n                        className={`react-timebomb-icon ${this.iconClass}`}\n                    />\n                    <Flex>\n                        {this.renderValue()}\n                        {showPlaceholder && (\n                            <Placeholder className=\"react-timebomb-placeholder\">\n                                {placeholder}\n                            </Placeholder>\n                        )}\n                    </Flex>\n                </Flex>\n                <Flex>\n                    {showClearer && (\n                        <ClearButton\n                            className=\"react-timebomb-clearer\"\n                            tabIndex={-1}\n                            onClick={this.onClear}\n                        >\n                            ×\n                        </ClearButton>\n                    )}\n                    {!timeOnly && (\n                        <ArrowButtonComp disabled={disabled} open={open} />\n                    )}\n                </Flex>\n            </Container>\n        );\n    }\n\n    private renderValue(): React.ReactNode {\n        const { open, disabled, mobile, value } = this.props;\n        const contentEditable = !disabled && !mobile;\n\n        if (!open && !value) {\n            return null;\n        }\n\n        const formatGroups = this.formatGroups;\n\n        return (\n            <Flex>\n                {formatGroups.map((group, i) => {\n                    if (group.split('').some(g => formatSplitExpr.test(g))) {\n                        return null;\n                    } else {\n                        const separator = formatGroups[i + 1];\n\n                        return (\n                            <Input\n                                data-react-timebomb-selectable\n                                contentEditable={contentEditable}\n                                disabled={disabled}\n                                data-placeholder={group}\n                                data-separator={replaceSpaceWithNbsp(separator)}\n                                key={group}\n                                data-group={group}\n                                ref={this.onSearchRef}\n                                onKeyDown={this.onKeyDown}\n                                onKeyUp={this.onKeyUp}\n                                onFocus={this.onFocus}\n                                onBlur={this.onBlur}\n                                onClick={this.onClick}\n                                onDoubleClick={this.onDblClick}\n                                onChange={this.onChange}\n                            />\n                        );\n                    }\n                })}\n            </Flex>\n        );\n    }\n\n    private onSearchRef(el: HTMLSpanElement | null): void {\n        if (el) {\n            this.inputs.push(el);\n        } else {\n            this.inputs = [];\n        }\n    }\n\n    private onKeyDown(e: React.KeyboardEvent<HTMLSpanElement>): void {\n        const {\n            onChangeValueText,\n            format,\n            value,\n            allowValidation\n        } = this.props;\n        const input = e.currentTarget;\n        const { innerText, nextSibling, previousSibling } = input;\n        const formatGroup = getAttribute(input, 'data-group');\n        const numericFormat = formatIsActualNumber(formatGroup);\n        const sel = getSelection();\n        const hasSelection = Boolean(sel.focusOffset - sel.baseOffset);\n        let numericValue = parseInt(innerText, 10);\n\n        switch (e.keyCode) {\n            case keys.ENTER:\n            case keys.ESC:\n            case keys.BACKSPACE:\n            case keys.DOT:\n            case keys.COMMA:\n                e.preventDefault();\n                return;\n            case keys.ARROW_RIGHT:\n                e.preventDefault();\n\n                if (nextSibling instanceof HTMLSpanElement) {\n                    nextSibling.focus();\n                } else {\n                    selectElement(input);\n                }\n                return;\n            case keys.ARROW_LEFT:\n                e.preventDefault();\n\n                if (previousSibling instanceof HTMLSpanElement) {\n                    previousSibling.focus();\n                } else {\n                    selectElement(input);\n                }\n                return;\n            case keys.ARROW_UP:\n            case keys.ARROW_DOWN:\n                e.preventDefault();\n\n                if (!numericFormat) {\n                    return;\n                }\n\n                const isArrowUp = e.keyCode === keys.ARROW_UP;\n\n                if (isNaN(numericValue)) {\n                    numericValue = 0;\n                }\n\n                if (isFinite(numericValue)) {\n                    const formatType = getFormatType(formatGroup);\n\n                    if (!allowValidation) {\n                        const add = e.shiftKey ? 10 : 1;\n                        const nextValue =\n                            numericValue + (isArrowUp ? add : -add);\n                        const valid = validateFormatGroup(\n                            nextValue,\n                            formatGroup\n                        );\n\n                        if (valid) {\n                            input.innerText =\n                                typeof valid === 'string'\n                                    ? valid\n                                    : formatNumber(nextValue);\n                        }\n                    } else {\n                        if (value && formatType) {\n                            const direction = isArrowUp ? 'add' : 'subtract';\n\n                            const newDate = manipulateDate(\n                                value,\n                                formatType,\n                                direction,\n                                e.shiftKey\n                            );\n                            const enabled = isEnabled(\n                                'day',\n                                newDate,\n                                this.props\n                            );\n\n                            if (enabled) {\n                                const dateParts = splitDate(newDate, format);\n\n                                this.inputs.map(\n                                    (inp, i) => (inp.innerText = dateParts[i])\n                                );\n                            }\n                        }\n                    }\n\n                    selectElement(input);\n                    onChangeValueText(joinDates(this.inputs, format));\n                }\n                return;\n        }\n\n        const char = stringFromCharCode(e.keyCode);\n        const groupValue = innerText && !hasSelection ? innerText + char : char;\n\n        if (META_KEYS.includes(e.keyCode) || e.metaKey || e.ctrlKey) {\n            return;\n        }\n\n        if (!numericFormat) {\n            e.preventDefault();\n            return;\n        }\n\n        const valid = validateFormatGroup(groupValue, formatGroup);\n\n        if (!valid) {\n            e.preventDefault();\n        } else if (typeof valid === 'string') {\n            e.preventDefault();\n\n            input.innerText = valid;\n        }\n\n        if (\n            this.state.allSelected &&\n            e.keyCode !== keys.BACKSPACE &&\n            e.keyCode !== keys.DELETE\n        ) {\n            const [firstInput] = this.inputs;\n            let validatedChar = validateFormatGroup(char, formatGroup);\n\n            if (validatedChar && validatedChar === true) {\n                validatedChar = char;\n            }\n\n            if (validatedChar) {\n                e.preventDefault();\n\n                this.inputs.forEach((el, i) => i !== 0 && (el.innerText = ''));\n\n                if (validatedChar.length === 2) {\n                    selectElement(firstInput);\n                } else {\n                    clearSelection();\n\n                    firstInput.innerText = validatedChar;\n                    firstInput.focus();\n\n                    selectElement(firstInput, [1, 1]);\n                }\n            }\n        }\n\n        // validate group\n        if (!hasSelection && innerText.length >= formatGroup.length) {\n            e.preventDefault();\n        }\n    }\n\n    private onKeyUp(e: React.KeyboardEvent<HTMLSpanElement>): void {\n        const { onChangeValueText, format, onSubmit, onToggle } = this.props;\n        const input = e.currentTarget;\n        const { innerText, nextSibling, previousSibling } = input;\n\n        if (e.keyCode === keys.ENTER) {\n            e.preventDefault();\n\n            if (this.focused) {\n                this.focused.blur();\n            }\n            onSubmit();\n            return;\n        }\n\n        if (e.keyCode === keys.ESC) {\n            onToggle();\n            return;\n        }\n\n        if (this.state.allSelected) {\n            if (e.keyCode === keys.BACKSPACE || e.keyCode === keys.DELETE) {\n                // delete all\n                this.inputs.forEach(el => (el.innerText = ''));\n\n                selectElement(this.inputs[0]);\n            }\n\n            this.setState({ allSelected: false });\n        }\n\n        // remove text / focus prev\n        else if (e.keyCode === keys.BACKSPACE) {\n            if (innerText) {\n                input.innerText = '';\n            } else if (previousSibling instanceof HTMLSpanElement) {\n                selectElement(previousSibling);\n            }\n        }\n\n        // focus next\n        else if (\n            (innerText.length >= getAttribute(input, 'data-group').length &&\n                !FORBIDDEN_KEYS.includes(e.keyCode)) ||\n            e.keyCode === keys.DOT ||\n            e.keyCode === keys.COMMA\n        ) {\n            if (!nextSibling) {\n                selectElement(input);\n            } else if (nextSibling instanceof HTMLSpanElement) {\n                selectElement(nextSibling);\n            }\n\n            onChangeValueText(joinDates(this.inputs, format));\n        }\n    }\n\n    private onClick(e: React.SyntheticEvent<HTMLSpanElement>): void {\n        selectElement(e.currentTarget);\n    }\n\n    private onDblClick(e: React.SyntheticEvent<HTMLSpanElement>) {\n        const input = e.currentTarget;\n\n        if (input.parentNode && this.inputs.some(el => Boolean(el.innerText))) {\n            selectElement(this.inputs[0]);\n            selectElement(input.parentNode as HTMLElement);\n            this.setState({ allSelected: true }, this.props.onAllSelect);\n        }\n    }\n\n    private onFocus = (() => {\n        let timeout: NodeJS.Timeout;\n\n        return (e: React.SyntheticEvent<HTMLSpanElement>) => {\n            clearTimeout(timeout);\n\n            const input = e.currentTarget;\n\n            selectElement(input);\n\n            timeout = setTimeout(() => {\n                if (!this.state.allSelected) {\n                    const formatGroup = getAttribute(input, 'data-group');\n\n                    this.props.onChangeFormatGroup(formatGroup);\n                }\n            }, 16);\n        };\n    })();\n\n    private onBlur(e: React.SyntheticEvent<HTMLSpanElement>): void {\n        if (!this.state.allSelected) {\n            const input = e.target as HTMLSpanElement;\n            const value = input.innerText;\n            const dataGroup = getAttribute(input, 'data-group');\n            const formatType = getFormatType(dataGroup);\n\n            if (formatType) {\n                const filledValue = fillZero(value, formatType);\n\n                if (filledValue) {\n                    input.innerText = filledValue;\n                }\n            }\n        }\n\n        // check if timebomb is still focused\n        setTimeout(() => {\n            const { focused } = this;\n\n            if (\n                this.props.open &&\n                focused &&\n                !getAttribute(focused, 'data-react-timebomb-selectable')\n            ) {\n                this.props.onToggle();\n            }\n        }, 0);\n    }\n\n    private onChange(e: React.KeyboardEvent<HTMLSpanElement>): void {\n        const { format, onChangeValueText } = this.props;\n        const input = e.currentTarget;\n        const { innerText, nextSibling } = input;\n\n        onChangeValueText(joinDates(this.inputs, format));\n\n        if (innerText.length >= getAttribute(input, 'data-group').length) {\n            if (nextSibling instanceof HTMLSpanElement) {\n                nextSibling.focus();\n            }\n        }\n    }\n\n    private onClear(e: React.MouseEvent<HTMLButtonElement>): void {\n        e.stopPropagation();\n\n        this.props.onClear();\n    }\n\n    private onToggle(e: React.SyntheticEvent<HTMLSpanElement>): void {\n        const { open, disabled, onToggle } = this.props;\n\n        if (disabled) {\n            return;\n        }\n\n        if (!this.inputs.some(inp => inp === e.target) || !open) {\n            onToggle();\n        }\n    }\n}\n"]}