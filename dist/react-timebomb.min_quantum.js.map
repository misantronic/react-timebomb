{"version":3,"sources":["src/value.tsx"],"names":["React","$fsx","r","styled_components_1","utils_1","button_1","arrow_button_1","exports","Flex","default","div","Container","props","disabled","Input","span","ClearButton","SmallButton","Placeholder","Icon","icon","WHITELIST_KEYS","keys","BACKSPACE","DELETE","TAB","FORBIDDEN_KEYS","SHIFT","ARROW_LEFT","ARROW_RIGHT","ARROW_UP","ARROW_DOWN","Value","PureComponent","[object Object]","super","this","searchInputs","state","onSearchRef","bind","onKeyDown","onKeyUp","onFocus","onClick","onBlur","onChange","onClear","onToggle","formatGroups","format","split","reduce","memo","char","prevChar","length","substr","focused","document","querySelector","iconClass","showTime","showDate","prevProps","open","value","some","inp","parts","splitDate","input","forEach","i","innerText","focus","selectText","forceUpdate","placeholder","ArrowButtonComp","arrowButtonComponent","ArrowButton","showPlaceholder","timeOnly","createElement","data-role","className","renderValue","tabIndex","map","group","separator","contentEditable","data-placeholder","data-separator","key","data-group","ref","data-react-timebomb-selectable","el","range","createRange","sel","getSelection","selectNodeContents","removeAllRanges","addRange","push","e","onChangeValueText","allowValidation","currentTarget","nextSibling","previousSibling","hasSelection","Boolean","focusOffset","baseOffset","numericValue","parseInt","keyCode","ENTER","ESC","preventDefault","HTMLSpanElement","isArrowUp","isNaN","isFinite","formatGroup","getAttribute","formatType","getFormatType","direction","newDate","manipulateDate","shiftKey","isEnabled","dateParts","add","nextValue","valid","validateFormatGroup","formatNumber","joinDates","dataValue","dataGroup","stringFromCharCode","groupValue","includes","metaKey","ctrlKey","onSubmit","blur","setAttribute","target","currentFormatGroup","setState","fillZero","setTimeout","stopPropagation"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport styled from 'styled-components';\nimport {\n    keys,\n    formatNumber,\n    splitDate,\n    joinDates,\n    stringFromCharCode,\n    validateFormatGroup,\n    getAttribute,\n    getFormatType,\n    manipulateDate,\n    isEnabled\n} from './utils';\nimport { ReactTimebombProps, ReactTimebombState } from './typings';\nimport { SmallButton } from './button';\nimport { ArrowButton } from './arrow-button';\n\nexport interface ValueProps {\n    open?: boolean;\n    value?: Date;\n    format: string;\n    placeholder: ReactTimebombProps['placeholder'];\n    minDate: ReactTimebombProps['minDate'];\n    maxDate: ReactTimebombProps['maxDate'];\n    showDate: ReactTimebombState['showDate'];\n    showTime: ReactTimebombState['showTime'];\n    allowValidation: ReactTimebombState['allowValidation'];\n    arrowButtonComponent: ReactTimebombProps['arrowButtonComponent'];\n    disabled: ReactTimebombProps['disabled'];\n    onToggle(): void;\n    onChangeValueText(valueText?: string, commit?: boolean): void;\n    onSubmit(): void;\n    onClear(): void;\n}\n\ninterface ValueState {\n    currentFormatGroup?: string;\n}\n\ninterface InputProps {\n    disabled?: boolean;\n}\n\nexport const Flex = styled.div`\n    display: flex;\n    align-items: center;\n    white-space: nowrap;\n    position: relative;\n`;\n\nexport const Container = styled(Flex)`\n    justify-content: space-between;\n    align-items: center;\n    padding: 5px 10px;\n    border: 1px solid #ccc;\n    cursor: ${(props: { disabled?: boolean }) =>\n        props.disabled ? 'not-allowed' : 'pointer'};\n    width: 100%;\n    height: 100%;\n    box-sizing: border-box;\n`;\n\nconst Input = styled.span`\n    padding: 2px 0 2px 0;\n    min-width: 1px;\n    cursor: ${(props: InputProps) => (props.disabled ? 'not-allowed' : 'text')};\n    pointer-events: ${(props: InputProps) =>\n        props.disabled ? 'none' : 'auto'};\n\n    &:focus {\n        outline: none;\n    }\n\n    &:last-of-type {\n        padding: 2px 10px 2px 0;\n    }\n\n    &:not(:last-of-type):after {\n        content: attr(data-separator);\n        width: 4px;\n        display: inline-block;\n    }\n\n    &:empty:before {\n        content: attr(data-placeholder);\n        color: #aaa;\n    }\n\n    &:empty:not(:last-of-type):after {\n        color: #aaa;\n    }\n`;\n\nexport const ClearButton = styled(SmallButton)`\n    font-size: 18px;\n`;\n\nexport const Placeholder = styled.span`\n    color: #aaa;\n    user-select: none;\n`;\n\nexport const Icon = styled.span`\n    margin-right: 5px;\n    user-select: none;\n\n    &:after {\n        content: '${(props: { icon: string }) => props.icon}';\n    }\n`;\n\nconst WHITELIST_KEYS = [keys.BACKSPACE, keys.DELETE, keys.TAB];\n\nconst FORBIDDEN_KEYS = [\n    keys.SHIFT,\n    keys.ARROW_LEFT,\n    keys.ARROW_RIGHT,\n    keys.ARROW_UP,\n    keys.ARROW_DOWN,\n    keys.TAB\n];\n\nexport class Value extends React.PureComponent<ValueProps, ValueState> {\n    private searchInputs: HTMLSpanElement[] = [];\n\n    private get formatGroups(): string[] {\n        return this.props.format.split('').reduce(\n            (memo, char) => {\n                const prevChar = memo[memo.length - 1];\n\n                if (prevChar && char === prevChar.substr(0, 1)) {\n                    memo[memo.length - 1] += char;\n                } else {\n                    memo = [...memo, char];\n                }\n\n                return memo;\n            },\n            [] as string[]\n        );\n    }\n\n    private get focused(): HTMLElement | null {\n        return document.querySelector(':focus');\n    }\n\n    private get iconClass(): 'time' | 'calendar' {\n        const { showTime, showDate } = this.props;\n\n        if (!showDate && showTime) {\n            return 'time';\n        }\n\n        return 'calendar';\n    }\n\n    private get icon() {\n        switch (this.iconClass) {\n            case 'calendar':\n                return '📅';\n            case 'time':\n                return '⏱';\n        }\n    }\n\n    constructor(props: ValueProps) {\n        super(props);\n\n        this.state = {};\n\n        this.onSearchRef = this.onSearchRef.bind(this);\n        this.onKeyDown = this.onKeyDown.bind(this);\n        this.onKeyUp = this.onKeyUp.bind(this);\n        this.onFocus = this.onFocus.bind(this);\n        this.onClick = this.onClick.bind(this);\n        this.onBlur = this.onBlur.bind(this);\n        this.onChange = this.onChange.bind(this);\n        this.onClear = this.onClear.bind(this);\n        this.onToggle = this.onToggle.bind(this);\n    }\n\n    public componentDidUpdate(prevProps: ValueProps): void {\n        const { open, value, format } = this.props;\n        const hasFocus = this.searchInputs.some(inp => inp === this.focused);\n\n        if (!hasFocus) {\n            if (open) {\n                if (prevProps.value !== value && value) {\n                    const parts = splitDate(value, format);\n                    const input = this.searchInputs[0];\n\n                    this.searchInputs.forEach(\n                        (input, i) => (input.innerText = parts[i])\n                    );\n\n                    if (input) {\n                        input.focus();\n                    }\n                }\n\n                if (!prevProps.open || value !== prevProps.value) {\n                    const input = this.searchInputs[0];\n\n                    if (input) {\n                        this.selectText(input);\n                    }\n                }\n            }\n        }\n\n        if (!open && value) {\n            const parts = splitDate(value, format);\n\n            this.searchInputs.forEach(\n                (input, i) => (input.innerText = parts[i])\n            );\n        }\n    }\n\n    public componentDidMount() {\n        if (this.props.value) {\n            this.forceUpdate();\n        }\n    }\n\n    public render(): React.ReactNode {\n        const {\n            placeholder,\n            value,\n            showDate,\n            showTime,\n            disabled,\n            open\n        } = this.props;\n        const ArrowButtonComp = this.props.arrowButtonComponent || ArrowButton;\n        const showPlaceholder = placeholder && !open;\n        const timeOnly = showTime && !showDate;\n\n        return (\n            <Container\n                data-role=\"value\"\n                className=\"react-slct-value react-timebomb-value\"\n                disabled={disabled}\n                onClick={this.onToggle}\n            >\n                <Flex>\n                    <Icon\n                        icon={this.icon}\n                        className={`react-timebomb-icon ${this.iconClass}`}\n                    />\n                    <Flex>\n                        {this.renderValue()}\n                        {showPlaceholder && (\n                            <Placeholder className=\"react-timebomb-placeholder\">\n                                {placeholder}\n                            </Placeholder>\n                        )}\n                    </Flex>\n                </Flex>\n                <Flex>\n                    {value && (\n                        <ClearButton\n                            className=\"react-timebomb-clearer\"\n                            tabIndex={-1}\n                            disabled={disabled}\n                            onClick={this.onClear}\n                        >\n                            ×\n                        </ClearButton>\n                    )}\n                    {!timeOnly && (\n                        <ArrowButtonComp disabled={disabled} open={open} />\n                    )}\n                </Flex>\n            </Container>\n        );\n    }\n\n    private renderValue(): React.ReactNode {\n        const { open, disabled, value } = this.props;\n\n        if (!open && !value) {\n            return null;\n        }\n\n        const { formatGroups } = this;\n\n        return (\n            <Flex>\n                {formatGroups.map((group, i) => {\n                    if (group === '.' || group === ':' || group === ' ') {\n                        return null;\n                    } else {\n                        const separator = formatGroups[i + 1];\n\n                        return (\n                            <Input\n                                contentEditable={!disabled}\n                                disabled={disabled}\n                                data-placeholder={group}\n                                data-separator={separator}\n                                key={group}\n                                data-group={group}\n                                ref={this.onSearchRef}\n                                data-react-timebomb-selectable\n                                onKeyDown={this.onKeyDown}\n                                onKeyUp={this.onKeyUp}\n                                onFocus={this.onFocus}\n                                onBlur={this.onBlur}\n                                onClick={this.onClick}\n                                onChange={this.onChange}\n                            />\n                        );\n                    }\n                })}\n            </Flex>\n        );\n    }\n\n    private selectText(el: HTMLElement | undefined) {\n        if (el) {\n            const range = document.createRange();\n            const sel = getSelection();\n\n            range.selectNodeContents(el);\n\n            sel.removeAllRanges();\n            sel.addRange(range);\n        }\n    }\n\n    private onSearchRef(el: HTMLSpanElement | null): void {\n        if (el) {\n            this.searchInputs.push(el);\n        } else {\n            this.searchInputs = [];\n        }\n    }\n\n    private onKeyDown(e: React.KeyboardEvent<HTMLSpanElement>): void {\n        const {\n            onChangeValueText,\n            format,\n            value,\n            allowValidation\n        } = this.props;\n        const input = e.currentTarget;\n        const { innerText, nextSibling, previousSibling } = input;\n        const sel = getSelection();\n        const hasSelection = Boolean(sel.focusOffset - sel.baseOffset);\n        let numericValue = parseInt(innerText, 10);\n\n        switch (e.keyCode) {\n            case keys.ENTER:\n            case keys.ESC:\n            case keys.BACKSPACE:\n                e.preventDefault();\n                return;\n            case keys.ARROW_RIGHT:\n                e.preventDefault();\n\n                if (nextSibling instanceof HTMLSpanElement) {\n                    nextSibling.focus();\n                } else {\n                    this.selectText(input);\n                }\n                return;\n            case keys.ARROW_LEFT:\n                e.preventDefault();\n\n                if (previousSibling instanceof HTMLSpanElement) {\n                    previousSibling.focus();\n                } else {\n                    this.selectText(input);\n                }\n                return;\n            case keys.ARROW_UP:\n            case keys.ARROW_DOWN:\n                e.preventDefault();\n\n                const isArrowUp = e.keyCode === keys.ARROW_UP;\n\n                if (isNaN(numericValue)) {\n                    numericValue = 0;\n                }\n\n                if (isFinite(numericValue)) {\n                    const formatGroup = getAttribute(input, 'data-group');\n                    const formatType = getFormatType(formatGroup);\n\n                    if (!allowValidation) {\n                        const add = e.shiftKey ? 10 : 1;\n                        const nextValue =\n                            numericValue + (isArrowUp ? add : -add);\n                        const valid = validateFormatGroup(\n                            nextValue,\n                            formatGroup\n                        );\n\n                        if (valid) {\n                            input.innerText =\n                                typeof valid === 'string'\n                                    ? valid\n                                    : formatNumber(nextValue);\n                        }\n                    } else {\n                        if (value && formatType) {\n                            const direction = isArrowUp ? 'add' : 'subtract';\n\n                            const newDate = manipulateDate(\n                                value,\n                                formatType,\n                                direction,\n                                e.shiftKey\n                            );\n                            const enabled = isEnabled(\n                                'day',\n                                newDate,\n                                this.props\n                            );\n\n                            if (enabled) {\n                                const dateParts = splitDate(newDate, format);\n\n                                this.searchInputs.map(\n                                    (inp, i) => (inp.innerText = dateParts[i])\n                                );\n                            }\n                        }\n                    }\n\n                    this.selectText(input);\n                    onChangeValueText(joinDates(this.searchInputs, format));\n                }\n                return;\n        }\n\n        const dataValue = getAttribute(input, 'data-value');\n        const dataGroup = getAttribute(input, 'data-group');\n        const char = stringFromCharCode(e.keyCode);\n        const groupValue = dataValue && !hasSelection ? dataValue + char : char;\n\n        if (WHITELIST_KEYS.includes(e.keyCode) || e.metaKey || e.ctrlKey) {\n            return;\n        }\n\n        const valid = validateFormatGroup(groupValue, dataGroup);\n\n        if (!valid) {\n            e.preventDefault();\n        } else if (typeof valid === 'string') {\n            e.preventDefault();\n\n            input.innerText = valid;\n        }\n\n        if (hasSelection) {\n            return;\n        }\n\n        // validate group\n        if (innerText.length >= dataGroup.length) {\n            e.preventDefault();\n        }\n    }\n\n    private onKeyUp(e: React.KeyboardEvent<HTMLSpanElement>): void {\n        const { onChangeValueText, format, onSubmit, onToggle } = this.props;\n        const input = e.currentTarget;\n        const { innerText, nextSibling, previousSibling } = input;\n\n        if (e.keyCode === keys.ENTER) {\n            e.preventDefault();\n\n            if (this.focused) {\n                this.focused.blur();\n            }\n            onSubmit();\n            return;\n        }\n\n        if (e.keyCode === keys.ESC) {\n            onToggle();\n            return;\n        }\n\n        // focus prev\n        if (e.keyCode === keys.BACKSPACE) {\n            if (innerText) {\n                input.innerText = '';\n            } else if (previousSibling instanceof HTMLSpanElement) {\n                this.selectText(previousSibling);\n            }\n        }\n\n        // focus next\n        else if (\n            innerText.length >= getAttribute(input, 'data-group').length &&\n            !FORBIDDEN_KEYS.includes(e.keyCode)\n        ) {\n            if (!nextSibling) {\n                this.selectText(input);\n            } else if (nextSibling instanceof HTMLSpanElement) {\n                this.selectText(nextSibling);\n            }\n\n            onChangeValueText(joinDates(this.searchInputs, format));\n        }\n\n        input.setAttribute('data-value', input.innerText);\n    }\n\n    private onClick(e: React.SyntheticEvent<HTMLSpanElement>): void {\n        this.selectText(e.currentTarget);\n    }\n\n    private onFocus(e: React.SyntheticEvent<HTMLSpanElement>): void {\n        const input = e.target as HTMLSpanElement;\n        const currentFormatGroup = getAttribute(input, 'data-group');\n\n        this.selectText(e.currentTarget);\n\n        this.setState({ currentFormatGroup });\n    }\n\n    private onBlur(e: React.SyntheticEvent<HTMLSpanElement>): void {\n        const input = e.target as HTMLSpanElement;\n        const value = input.innerText;\n        const dataGroup = getAttribute(input, 'data-group');\n        const formatType = getFormatType(dataGroup);\n\n        const fillZero = () => {\n            const innerText = `0${value}`;\n\n            input.innerText = innerText;\n            input.setAttribute('data-value', innerText);\n        };\n\n        switch (formatType) {\n            case 'day':\n                if (value === '1' || value === '2' || value === '3') {\n                    fillZero();\n                }\n                break;\n            case 'month':\n                if (value === '1') {\n                    fillZero();\n                }\n                break;\n        }\n\n        // check if timebomb is still focused\n        setTimeout(() => {\n            const { focused } = this;\n\n            if (\n                this.props.open &&\n                focused &&\n                !getAttribute(focused, 'data-react-timebomb-selectable')\n            ) {\n                this.props.onToggle();\n            }\n        }, 0);\n    }\n\n    private onChange(e: React.KeyboardEvent<HTMLSpanElement>): void {\n        const { format, onChangeValueText } = this.props;\n        const input = e.currentTarget;\n        const { innerText, nextSibling } = input;\n\n        onChangeValueText(joinDates(this.searchInputs, format));\n\n        if (innerText.length >= getAttribute(input, 'data-group').length) {\n            if (nextSibling instanceof HTMLSpanElement) {\n                nextSibling.focus();\n            }\n        }\n    }\n\n    private onClear(e: React.MouseEvent<HTMLButtonElement>): void {\n        e.stopPropagation();\n\n        this.props.onClear();\n    }\n\n    private onToggle(e: React.SyntheticEvent<HTMLSpanElement>): void {\n        const { open, disabled, onToggle } = this.props;\n\n        if (disabled) {\n            return;\n        }\n\n        if (!this.searchInputs.some(inp => inp === e.target) || !open) {\n            onToggle();\n        }\n    }\n}\n"]}