{"version":3,"sources":["src/utils.ts","src/value.tsx"],"names":["moment_1","$fsx","r","momentImport","moment","default","formatSplit","dateFormat","date","format","isArray","map","getFormatType","test","startOfDay","newDate","Date","setHours","addDays","num","add","toDate","Array","val","exports","validateDate","dates","instance","isValid","undefined","filter","d","Boolean","length","validateFormatGroup","input","isFinite","int","parseInt","char","String","strLen","startsWith","stringFromCharCode","keyCode","charCode","Math","floor","fromCharCode","formatNumber","number","splitDate","split","joinDates","parts","strParts","part","HTMLElement","innerText","splittedFormat","join","spaceFormat","momentDate","parsingFlags","overflow","parsedDateParts","clearSelection","sel","getSelection","empty","removeAllRanges","getWeekOfYear","isoWeek","startOfWeek","startOf","endOfWeek","endOf","endOfDay","subtractDays","manipulateDate","subtract","isSame","isBefore","inp","isAfter","dateA","isEnabled","isSameOrAfter","minDate","context","getAttribute","attr","isDateFormat","isTimeFormat","a","b","getTime","keys","ARROW_UP","ARROW_RIGHT","ARROW_DOWN","ARROW_LEFT","ENTER","TAB","ESC","BACKSPACE","DELETE","SPACE","SHIFT","DOT","COMMA","React","styled_components_1","utils_1","button_1","arrow_button_1","Flex","div","Container","props","disabled","Input","span","ClearButton","SmallButton","Placeholder","Icon","icon","WHITELIST_KEYS","FORBIDDEN_KEYS","Value","PureComponent","[object Object]","super","this","searchInputs","state","onSearchRef","bind","onKeyDown","onKeyUp","onFocus","onClick","onBlur","onChange","onClear","onToggle","formatGroups","reduce","memo","prevChar","substr","focused","document","querySelector","iconClass","showTime","showDate","prevProps","open","value","some","forEach","i","focus","selectText","forceUpdate","placeholder","ArrowButtonComp","arrowButtonComponent","ArrowButton","showPlaceholder","timeOnly","createElement","data-role","className","renderValue","tabIndex","group","separator","contentEditable","data-placeholder","data-separator","key","data-group","ref","data-react-timebomb-selectable","el","range","createRange","selectNodeContents","addRange","push","e","onChangeValueText","allowValidation","currentTarget","nextSibling","previousSibling","hasSelection","focusOffset","baseOffset","numericValue","preventDefault","HTMLSpanElement","isArrowUp","isNaN","formatGroup","formatType","direction","shiftKey","dateParts","nextValue","valid","dataValue","dataGroup","groupValue","includes","metaKey","ctrlKey","onSubmit","blur","setAttribute","target","currentFormatGroup","setState","fillZero","setTimeout","stopPropagation"],"mappings":"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","sourcesContent":["// @ts-ignore\nimport momentDefaultImport from 'moment';\nimport * as momentImport from 'moment';\nimport { ReactTimebombDate } from './typings';\n\nconst moment: typeof momentImport = momentDefaultImport || momentImport;\nconst formatSplit = /[.|:|-|\\\\|_|\\s]/;\n\ntype FormatType = 'day' | 'month' | 'year' | 'hour' | 'minute' | 'second';\n\nexport function dateFormat(\n    date: ReactTimebombDate,\n    format: string\n): string | string[] {\n    if (isArray(date)) {\n        return date.map(date => moment(date).format(format));\n    } else {\n        return moment(date).format(format);\n    }\n}\n\nexport function validateDate(\n    date: string | string[] | undefined,\n    format: string\n): ReactTimebombDate {\n    if (isArray(date)) {\n        const dates = date\n            .map(date => {\n                const instance = moment(date, format, true);\n\n                return instance.isValid() ? instance.toDate() : undefined;\n            })\n            .filter(d => Boolean(d)) as Date[];\n\n        return dates.length === 0 ? undefined : dates;\n    } else {\n        const instance = moment(date, format, true);\n\n        return instance.isValid() ? instance.toDate() : undefined;\n    }\n}\n\nexport function getFormatType(format: string): FormatType | undefined {\n    if (/d/i.test(format)) {\n        return 'day';\n    }\n\n    if (/M/.test(format)) {\n        return 'month';\n    }\n\n    if (/y/i.test(format)) {\n        return 'year';\n    }\n\n    if (/h/i.test(format)) {\n        return 'hour';\n    }\n\n    if (/m/.test(format)) {\n        return 'minute';\n    }\n\n    if (/s/.test(format)) {\n        return 'second';\n    }\n\n    return undefined;\n}\n\n/** @return returns a string with transformed value, true for valid input or false for invalid input */\nexport function validateFormatGroup(\n    input: string | number,\n    format: string\n): boolean | string {\n    if (isFinite(input as any)) {\n        const int = typeof input === 'string' ? parseInt(input, 10) : input;\n        const char = String(input);\n        const strLen = char.length;\n        const type = getFormatType(format);\n\n        switch (type) {\n            case 'day':\n                if (strLen === 1) {\n                    if (int >= 0 && int <= 3) {\n                        return true;\n                    } else {\n                        return `0${input}`;\n                    }\n                }\n\n                if (strLen === 2 && int >= 1 && int <= 31) {\n                    return true;\n                }\n                break;\n            case 'month':\n                if (strLen === 1) {\n                    if (int === 0 || int === 1) {\n                        return true;\n                    } else {\n                        return `0${input}`;\n                    }\n                }\n\n                if (strLen === 2 && int >= 0 && int <= 12) {\n                    return true;\n                }\n                break;\n            case 'year':\n                if (strLen === 1 && (int === 1 || int === 2)) {\n                    return true;\n                }\n\n                if (\n                    strLen >= 2 &&\n                    (char.startsWith('19') || char.startsWith('20'))\n                ) {\n                    return true;\n                }\n                break;\n            case 'hour':\n                if (strLen === 1) {\n                    if (int >= 0 && int <= 2) {\n                        return true;\n                    } else {\n                        return `0${input}`;\n                    }\n                }\n\n                if (strLen >= 2 && int >= 0 && int <= 24) {\n                    return true;\n                }\n                break;\n            case 'minute':\n            case 'second':\n                if (strLen === 1) {\n                    if (int >= 0 && int <= 5) {\n                        return true;\n                    } else {\n                        return `0${input}`;\n                    }\n                }\n\n                if (strLen >= 2 && int >= 0 && int <= 59) {\n                    return true;\n                }\n                break;\n        }\n    }\n\n    return false;\n}\n\nexport function stringFromCharCode(keyCode: number): string {\n    const charCode = keyCode - 48 * Math.floor(keyCode / 48);\n\n    return String.fromCharCode(96 <= keyCode ? charCode : keyCode);\n}\n\nexport function formatNumber(number: Number): string {\n    if (number <= 1) {\n        return '01';\n    }\n\n    if (number <= 9) {\n        return `0${number}`;\n    }\n\n    return String(number);\n}\n\nexport function splitDate(date: Date, format: string): string[] {\n    return (dateFormat(date, format) as string).split(formatSplit);\n}\n\nexport function joinDates(\n    parts: (string | HTMLElement)[],\n    format: string\n): string {\n    const strParts = parts\n        .map(part => (part instanceof HTMLElement ? part.innerText : part))\n        .filter(val => val);\n    const splittedFormat = format.split(formatSplit);\n\n    if (strParts.length !== splittedFormat.length) {\n        return '';\n    }\n\n    const date = strParts.join(' ');\n    const spaceFormat = splittedFormat.join(' ');\n    const momentDate = moment(date, spaceFormat);\n    const parsingFlags = momentDate.parsingFlags();\n\n    if (parsingFlags.overflow === 2) {\n        return moment(\n            // @ts-ignore\n            new Date(...parsingFlags.parsedDateParts)\n        ).format(format);\n    }\n\n    return momentDate.format(format);\n}\n\nexport function clearSelection(): void {\n    const sel = getSelection();\n\n    if (sel.empty) {\n        // Chrome\n        sel.empty();\n    } else if (sel.removeAllRanges) {\n        // Firefox\n        sel.removeAllRanges();\n    }\n}\n\nexport function getWeekOfYear(date: Date): number {\n    return moment(date).isoWeek();\n}\n\nexport function startOfWeek(date: Date): Date {\n    return moment(date)\n        .startOf('isoWeek')\n        .toDate();\n}\n\nexport function endOfWeek(date: Date): Date {\n    return moment(date)\n        .endOf('isoWeek')\n        .toDate();\n}\n\nexport function startOfDay(date: Date): Date {\n    const newDate = new Date(date);\n\n    newDate.setHours(0, 0, 0, 0);\n\n    return newDate;\n}\n\nexport function endOfDay(date: Date): Date {\n    const newDate = new Date(date);\n\n    newDate.setHours(23, 59, 59, 999);\n\n    return newDate;\n}\n\nexport function addDays(date: Date, num: number): Date {\n    return moment(date)\n        .add(num, 'days')\n        .toDate();\n}\n\nexport function addMonths(date: Date, num: number): Date {\n    return moment(date)\n        .add(num, 'months')\n        .toDate();\n}\n\nexport function addYears(date: Date, num: number): Date {\n    return moment(date)\n        .add(num, 'years')\n        .toDate();\n}\n\nexport function addHours(date: Date, num: number): Date {\n    return moment(date)\n        .add(num, 'hours')\n        .toDate();\n}\n\nexport function addMinutes(date: Date, num: number): Date {\n    return moment(date)\n        .add(num, 'minutes')\n        .toDate();\n}\n\nexport function addSeconds(date: Date, num: number): Date {\n    return moment(date)\n        .add(num, 'seconds')\n        .toDate();\n}\n\nexport function subtractSeconds(date: Date, num: number): Date {\n    return moment(date)\n        .subtract(num, 'seconds')\n        .toDate();\n}\n\nexport function subtractMinutes(date: Date, num: number): Date {\n    return moment(date)\n        .subtract(num, 'minutes')\n        .toDate();\n}\n\nexport function subtractHours(date: Date, num: number): Date {\n    return moment(date)\n        .subtract(num, 'hours')\n        .toDate();\n}\n\nexport function subtractDays(date: Date, num: number): Date {\n    return moment(date)\n        .subtract(num, 'days')\n        .toDate();\n}\n\nexport function subtractMonths(date: Date, num: number): Date {\n    return moment(date)\n        .subtract(num, 'months')\n        .toDate();\n}\n\nexport function subtractYears(date: Date, num: number): Date {\n    return moment(date)\n        .subtract(num, 'years')\n        .toDate();\n}\n\nexport function manipulateDate(\n    date: Date,\n    formatType: FormatType,\n    direction: 'add' | 'subtract',\n    shift = false\n): Date {\n    switch (formatType) {\n        case 'day':\n            if (direction === 'add') return addDays(date, 1);\n            if (direction === 'subtract') return subtractDays(date, 1);\n            break;\n        case 'month':\n            if (direction === 'add') return addMonths(date, 1);\n            if (direction === 'subtract') return subtractMonths(date, 1);\n            break;\n        case 'year':\n            if (direction === 'add') return addYears(date, 1);\n            if (direction === 'subtract') return subtractYears(date, 1);\n            break;\n        case 'hour':\n            if (direction === 'add') return addHours(date, shift ? 10 : 1);\n            if (direction === 'subtract')\n                return subtractHours(date, shift ? 10 : 1);\n            break;\n        case 'minute':\n            if (direction === 'add') return addMinutes(date, shift ? 10 : 1);\n            if (direction === 'subtract')\n                return subtractMinutes(date, shift ? 10 : 1);\n            break;\n        case 'second':\n            if (direction === 'add') return addSeconds(date, shift ? 10 : 1);\n            if (direction === 'subtract')\n                return subtractSeconds(date, shift ? 10 : 1);\n            break;\n    }\n\n    return new Date();\n}\n\nexport function startOfMonth(date: Date): Date {\n    const newDate = new Date(date);\n\n    newDate.setDate(1);\n    newDate.setHours(0, 0, 0, 0);\n\n    return newDate;\n}\n\nexport function endOfMonth(date: Date): Date {\n    return new Date(date.getFullYear(), date.getMonth() + 1, 0);\n}\n\nexport function isUndefined(val): val is undefined {\n    return val === null || val === undefined;\n}\n\nexport function setDate(date: Date, hour: number, min?: number): Date {\n    const newDate = new Date(date);\n\n    newDate.setHours(hour, min);\n\n    return newDate;\n}\n\nexport function isToday(date: Date): boolean {\n    return moment(date).isSame(new Date(), 'day');\n}\n\nexport function isBefore(date: Date, inp: Date) {\n    return moment(date).isBefore(inp, 'day');\n}\n\nexport function isAfter(date: Date, inp: Date) {\n    return moment(date).isAfter(inp, 'day');\n}\n\nexport function dateEqual(\n    dateA?: ReactTimebombDate,\n    dateB?: ReactTimebombDate,\n    considerTime = false\n) {\n    if (!dateA || !dateB) {\n        return false;\n    }\n\n    if (considerTime) {\n        if (isArray(dateA)) {\n            dateA = dateA.map(startOfDay);\n        } else {\n            dateA = startOfDay(dateA);\n        }\n\n        if (isArray(dateB)) {\n            dateB = dateB.map(startOfDay);\n        } else {\n            dateB = startOfDay(dateB);\n        }\n    }\n\n    if (isArray(dateA) && isArray(dateB)) {\n        return dateA.every((date, i) => {\n            const dBi = dateB![i];\n\n            if (date && dBi) {\n                return date.getTime() === dBi.getTime();\n            }\n\n            return false;\n        });\n    } else if (isArray(dateA) && dateB instanceof Date) {\n        return dateA.some(d => d.getTime() === (dateB as Date).getTime());\n    } else if (isArray(dateB) && dateA instanceof Date) {\n        return dateB.some(d => d.getTime() === (dateA as Date).getTime());\n    } else if (!isArray(dateA) && !isArray(dateB)) {\n        return dateA.getTime() === dateB.getTime();\n    }\n\n    return false;\n}\n\nexport function getMonthNames(short?: boolean): string[] {\n    if (short) {\n        return moment.monthsShort();\n    }\n\n    return moment.months();\n}\n\nexport function isEnabled(\n    context: 'year' | 'month' | 'day',\n    date: Date,\n    { minDate, maxDate }: { minDate?: Date; maxDate?: Date }\n): boolean {\n    if (!minDate && !maxDate) {\n        return true;\n    }\n\n    if (minDate && !maxDate) {\n        return moment(date).isSameOrAfter(minDate, context);\n    }\n\n    if (!minDate && maxDate) {\n        return moment(date).isSameOrBefore(maxDate, context);\n    }\n\n    return moment(date).isBetween(minDate, maxDate, context, '[]');\n}\n\nexport function getAttribute(input: Element, attr: string): string {\n    return input.getAttribute(attr)!;\n}\n\nexport function isDateFormat(format: string) {\n    return Boolean(/D|M|Y/.test(format));\n}\n\nexport function isTimeFormat(format: string) {\n    return Boolean(/H|h|m|k|a|S|s/.test(format));\n}\n\nexport function sortDates(a: Date, b: Date) {\n    return a.getTime() - b.getTime();\n}\n\nexport function isArray(val: any): val is any[] {\n    return Array.isArray(val);\n}\n\nexport const keys = {\n    ARROW_UP: 38,\n    ARROW_RIGHT: 39,\n    ARROW_DOWN: 40,\n    ARROW_LEFT: 37,\n    ENTER: 13,\n    TAB: 9,\n    ESC: 27,\n    BACKSPACE: 8,\n    DELETE: 46,\n    SPACE: 32,\n    SHIFT: 16,\n    DOT: 190,\n    COMMA: 188\n};\n","import * as React from 'react';\nimport styled from 'styled-components';\nimport {\n    keys,\n    formatNumber,\n    splitDate,\n    joinDates,\n    stringFromCharCode,\n    validateFormatGroup,\n    getAttribute,\n    getFormatType,\n    manipulateDate,\n    isEnabled\n} from './utils';\nimport { ReactTimebombProps, ReactTimebombState } from './typings';\nimport { SmallButton } from './button';\nimport { ArrowButton } from './arrow-button';\n\nexport interface ValueProps {\n    open?: boolean;\n    value?: Date;\n    format: string;\n    placeholder: ReactTimebombProps['placeholder'];\n    minDate: ReactTimebombProps['minDate'];\n    maxDate: ReactTimebombProps['maxDate'];\n    showDate: ReactTimebombState['showDate'];\n    showTime: ReactTimebombState['showTime'];\n    allowValidation: ReactTimebombState['allowValidation'];\n    arrowButtonComponent: ReactTimebombProps['arrowButtonComponent'];\n    disabled: ReactTimebombProps['disabled'];\n    onToggle(): void;\n    onChangeValueText(valueText?: string, commit?: boolean): void;\n    onSubmit(): void;\n    onClear(): void;\n}\n\ninterface ValueState {\n    currentFormatGroup?: string;\n}\n\ninterface InputProps {\n    disabled?: boolean;\n}\n\nexport const Flex = styled.div`\n    display: flex;\n    align-items: center;\n    white-space: nowrap;\n    position: relative;\n`;\n\nexport const Container = styled(Flex)`\n    justify-content: space-between;\n    align-items: center;\n    padding: 5px 10px;\n    border: 1px solid #ccc;\n    cursor: ${(props: { disabled?: boolean }) =>\n        props.disabled ? 'not-allowed' : 'pointer'};\n    width: 100%;\n    height: 100%;\n    box-sizing: border-box;\n`;\n\nconst Input = styled.span`\n    padding: 2px 0 2px 0;\n    min-width: 1px;\n    cursor: ${(props: InputProps) => (props.disabled ? 'not-allowed' : 'text')};\n    pointer-events: ${(props: InputProps) =>\n        props.disabled ? 'none' : 'auto'};\n\n    &:focus {\n        outline: none;\n    }\n\n    &:last-of-type {\n        padding: 2px 10px 2px 0;\n    }\n\n    &:not(:last-of-type):after {\n        content: attr(data-separator);\n        width: 4px;\n        display: inline-block;\n    }\n\n    &:empty:before {\n        content: attr(data-placeholder);\n        color: #aaa;\n    }\n\n    &:empty:not(:last-of-type):after {\n        color: #aaa;\n    }\n`;\n\nexport const ClearButton = styled(SmallButton)`\n    font-size: 18px;\n`;\n\nexport const Placeholder = styled.span`\n    color: #aaa;\n    user-select: none;\n`;\n\nexport const Icon = styled.span`\n    margin-right: 5px;\n    user-select: none;\n\n    &:after {\n        content: '${(props: { icon: string }) => props.icon}';\n    }\n`;\n\nconst WHITELIST_KEYS = [keys.BACKSPACE, keys.DELETE, keys.TAB];\n\nconst FORBIDDEN_KEYS = [\n    keys.SHIFT,\n    keys.ARROW_LEFT,\n    keys.ARROW_RIGHT,\n    keys.ARROW_UP,\n    keys.ARROW_DOWN,\n    keys.TAB\n];\n\nexport class Value extends React.PureComponent<ValueProps, ValueState> {\n    private searchInputs: HTMLSpanElement[] = [];\n\n    private get formatGroups(): string[] {\n        return this.props.format.split('').reduce(\n            (memo, char) => {\n                const prevChar = memo[memo.length - 1];\n\n                if (prevChar && char === prevChar.substr(0, 1)) {\n                    memo[memo.length - 1] += char;\n                } else {\n                    memo = [...memo, char];\n                }\n\n                return memo;\n            },\n            [] as string[]\n        );\n    }\n\n    private get focused(): HTMLElement | null {\n        return document.querySelector(':focus');\n    }\n\n    private get iconClass(): 'time' | 'calendar' {\n        const { showTime, showDate } = this.props;\n\n        if (!showDate && showTime) {\n            return 'time';\n        }\n\n        return 'calendar';\n    }\n\n    private get icon() {\n        switch (this.iconClass) {\n            case 'calendar':\n                return 'ðŸ“…';\n            case 'time':\n                return 'â±';\n        }\n    }\n\n    constructor(props: ValueProps) {\n        super(props);\n\n        this.state = {};\n\n        this.onSearchRef = this.onSearchRef.bind(this);\n        this.onKeyDown = this.onKeyDown.bind(this);\n        this.onKeyUp = this.onKeyUp.bind(this);\n        this.onFocus = this.onFocus.bind(this);\n        this.onClick = this.onClick.bind(this);\n        this.onBlur = this.onBlur.bind(this);\n        this.onChange = this.onChange.bind(this);\n        this.onClear = this.onClear.bind(this);\n        this.onToggle = this.onToggle.bind(this);\n    }\n\n    public componentDidUpdate(prevProps: ValueProps): void {\n        const { open, value, format } = this.props;\n        const hasFocus = this.searchInputs.some(inp => inp === this.focused);\n\n        if (!hasFocus) {\n            if (open) {\n                if (prevProps.value !== value && value) {\n                    const parts = splitDate(value, format);\n                    const input = this.searchInputs[0];\n\n                    this.searchInputs.forEach(\n                        (input, i) => (input.innerText = parts[i])\n                    );\n\n                    if (input) {\n                        input.focus();\n                    }\n                }\n\n                if (!prevProps.open || value !== prevProps.value) {\n                    const input = this.searchInputs[0];\n\n                    if (input) {\n                        this.selectText(input);\n                    }\n                }\n            }\n        }\n\n        if (!open && value) {\n            const parts = splitDate(value, format);\n\n            this.searchInputs.forEach(\n                (input, i) => (input.innerText = parts[i])\n            );\n        }\n    }\n\n    public componentDidMount() {\n        if (this.props.value) {\n            this.forceUpdate();\n        }\n    }\n\n    public render(): React.ReactNode {\n        const {\n            placeholder,\n            value,\n            showDate,\n            showTime,\n            disabled,\n            open\n        } = this.props;\n        const ArrowButtonComp = this.props.arrowButtonComponent || ArrowButton;\n        const showPlaceholder = placeholder && !open;\n        const timeOnly = showTime && !showDate;\n\n        return (\n            <Container\n                data-role=\"value\"\n                className=\"react-slct-value react-timebomb-value\"\n                disabled={disabled}\n                onClick={this.onToggle}\n            >\n                <Flex>\n                    <Icon\n                        icon={this.icon}\n                        className={`react-timebomb-icon ${this.iconClass}`}\n                    />\n                    <Flex>\n                        {this.renderValue()}\n                        {showPlaceholder && (\n                            <Placeholder className=\"react-timebomb-placeholder\">\n                                {placeholder}\n                            </Placeholder>\n                        )}\n                    </Flex>\n                </Flex>\n                <Flex>\n                    {value && (\n                        <ClearButton\n                            className=\"react-timebomb-clearer\"\n                            tabIndex={-1}\n                            disabled={disabled}\n                            onClick={this.onClear}\n                        >\n                            Ã—\n                        </ClearButton>\n                    )}\n                    {!timeOnly && (\n                        <ArrowButtonComp disabled={disabled} open={open} />\n                    )}\n                </Flex>\n            </Container>\n        );\n    }\n\n    private renderValue(): React.ReactNode {\n        const { open, disabled, value } = this.props;\n\n        if (!open && !value) {\n            return null;\n        }\n\n        const { formatGroups } = this;\n\n        return (\n            <Flex>\n                {formatGroups.map((group, i) => {\n                    if (group === '.' || group === ':' || group === ' ') {\n                        return null;\n                    } else {\n                        const separator = formatGroups[i + 1];\n\n                        return (\n                            <Input\n                                contentEditable={!disabled}\n                                disabled={disabled}\n                                data-placeholder={group}\n                                data-separator={separator}\n                                key={group}\n                                data-group={group}\n                                ref={this.onSearchRef}\n                                data-react-timebomb-selectable\n                                onKeyDown={this.onKeyDown}\n                                onKeyUp={this.onKeyUp}\n                                onFocus={this.onFocus}\n                                onBlur={this.onBlur}\n                                onClick={this.onClick}\n                                onChange={this.onChange}\n                            />\n                        );\n                    }\n                })}\n            </Flex>\n        );\n    }\n\n    private selectText(el: HTMLElement | undefined) {\n        if (el) {\n            const range = document.createRange();\n            const sel = getSelection();\n\n            range.selectNodeContents(el);\n\n            sel.removeAllRanges();\n            sel.addRange(range);\n        }\n    }\n\n    private onSearchRef(el: HTMLSpanElement | null): void {\n        if (el) {\n            this.searchInputs.push(el);\n        } else {\n            this.searchInputs = [];\n        }\n    }\n\n    private onKeyDown(e: React.KeyboardEvent<HTMLSpanElement>): void {\n        const {\n            onChangeValueText,\n            format,\n            value,\n            allowValidation\n        } = this.props;\n        const input = e.currentTarget;\n        const { innerText, nextSibling, previousSibling } = input;\n        const sel = getSelection();\n        const hasSelection = Boolean(sel.focusOffset - sel.baseOffset);\n        let numericValue = parseInt(innerText, 10);\n\n        switch (e.keyCode) {\n            case keys.ENTER:\n            case keys.ESC:\n            case keys.BACKSPACE:\n            case keys.DOT:\n            case keys.COMMA:\n                e.preventDefault();\n                return;\n            case keys.ARROW_RIGHT:\n                e.preventDefault();\n\n                if (nextSibling instanceof HTMLSpanElement) {\n                    nextSibling.focus();\n                } else {\n                    this.selectText(input);\n                }\n                return;\n            case keys.ARROW_LEFT:\n                e.preventDefault();\n\n                if (previousSibling instanceof HTMLSpanElement) {\n                    previousSibling.focus();\n                } else {\n                    this.selectText(input);\n                }\n                return;\n            case keys.ARROW_UP:\n            case keys.ARROW_DOWN:\n                e.preventDefault();\n\n                const isArrowUp = e.keyCode === keys.ARROW_UP;\n\n                if (isNaN(numericValue)) {\n                    numericValue = 0;\n                }\n\n                if (isFinite(numericValue)) {\n                    const formatGroup = getAttribute(input, 'data-group');\n                    const formatType = getFormatType(formatGroup);\n\n                    if (!allowValidation) {\n                        const add = e.shiftKey ? 10 : 1;\n                        const nextValue =\n                            numericValue + (isArrowUp ? add : -add);\n                        const valid = validateFormatGroup(\n                            nextValue,\n                            formatGroup\n                        );\n\n                        if (valid) {\n                            input.innerText =\n                                typeof valid === 'string'\n                                    ? valid\n                                    : formatNumber(nextValue);\n                        }\n                    } else {\n                        if (value && formatType) {\n                            const direction = isArrowUp ? 'add' : 'subtract';\n\n                            const newDate = manipulateDate(\n                                value,\n                                formatType,\n                                direction,\n                                e.shiftKey\n                            );\n                            const enabled = isEnabled(\n                                'day',\n                                newDate,\n                                this.props\n                            );\n\n                            if (enabled) {\n                                const dateParts = splitDate(newDate, format);\n\n                                this.searchInputs.map(\n                                    (inp, i) => (inp.innerText = dateParts[i])\n                                );\n                            }\n                        }\n                    }\n\n                    this.selectText(input);\n                    onChangeValueText(joinDates(this.searchInputs, format));\n                }\n                return;\n        }\n\n        const dataValue = getAttribute(input, 'data-value');\n        const dataGroup = getAttribute(input, 'data-group');\n        const char = stringFromCharCode(e.keyCode);\n        const groupValue = dataValue && !hasSelection ? dataValue + char : char;\n\n        if (WHITELIST_KEYS.includes(e.keyCode) || e.metaKey || e.ctrlKey) {\n            return;\n        }\n\n        const valid = validateFormatGroup(groupValue, dataGroup);\n\n        if (!valid) {\n            e.preventDefault();\n        } else if (typeof valid === 'string') {\n            e.preventDefault();\n\n            input.innerText = valid;\n        }\n\n        if (hasSelection) {\n            return;\n        }\n\n        // validate group\n        if (innerText.length >= dataGroup.length) {\n            e.preventDefault();\n        }\n    }\n\n    private onKeyUp(e: React.KeyboardEvent<HTMLSpanElement>): void {\n        const { onChangeValueText, format, onSubmit, onToggle } = this.props;\n        const input = e.currentTarget;\n        const { innerText, nextSibling, previousSibling } = input;\n\n        if (e.keyCode === keys.ENTER) {\n            e.preventDefault();\n\n            if (this.focused) {\n                this.focused.blur();\n            }\n            onSubmit();\n            return;\n        }\n\n        if (e.keyCode === keys.ESC) {\n            onToggle();\n            return;\n        }\n\n        // focus prev\n        if (e.keyCode === keys.BACKSPACE) {\n            if (innerText) {\n                input.innerText = '';\n            } else if (previousSibling instanceof HTMLSpanElement) {\n                this.selectText(previousSibling);\n            }\n        }\n\n        // focus next\n        else if (\n            (innerText.length >= getAttribute(input, 'data-group').length &&\n                !FORBIDDEN_KEYS.includes(e.keyCode)) ||\n            e.keyCode === keys.DOT ||\n            e.keyCode === keys.COMMA\n        ) {\n            if (!nextSibling) {\n                this.selectText(input);\n            } else if (nextSibling instanceof HTMLSpanElement) {\n                this.selectText(nextSibling);\n            }\n\n            onChangeValueText(joinDates(this.searchInputs, format));\n        }\n\n        input.setAttribute('data-value', input.innerText);\n    }\n\n    private onClick(e: React.SyntheticEvent<HTMLSpanElement>): void {\n        this.selectText(e.currentTarget);\n    }\n\n    private onFocus(e: React.SyntheticEvent<HTMLSpanElement>): void {\n        const input = e.target as HTMLSpanElement;\n        const currentFormatGroup = getAttribute(input, 'data-group');\n\n        this.selectText(e.currentTarget);\n\n        this.setState({ currentFormatGroup });\n    }\n\n    private onBlur(e: React.SyntheticEvent<HTMLSpanElement>): void {\n        const input = e.target as HTMLSpanElement;\n        const value = input.innerText;\n        const dataGroup = getAttribute(input, 'data-group');\n        const formatType = getFormatType(dataGroup);\n\n        const fillZero = () => {\n            const innerText = `0${value}`;\n\n            input.innerText = innerText;\n            input.setAttribute('data-value', innerText);\n        };\n\n        switch (formatType) {\n            case 'day':\n                if (value === '1' || value === '2' || value === '3') {\n                    fillZero();\n                }\n                break;\n            case 'month':\n                if (value === '1') {\n                    fillZero();\n                }\n                break;\n        }\n\n        // check if timebomb is still focused\n        setTimeout(() => {\n            const { focused } = this;\n\n            if (\n                this.props.open &&\n                focused &&\n                !getAttribute(focused, 'data-react-timebomb-selectable')\n            ) {\n                this.props.onToggle();\n            }\n        }, 0);\n    }\n\n    private onChange(e: React.KeyboardEvent<HTMLSpanElement>): void {\n        const { format, onChangeValueText } = this.props;\n        const input = e.currentTarget;\n        const { innerText, nextSibling } = input;\n\n        onChangeValueText(joinDates(this.searchInputs, format));\n\n        if (innerText.length >= getAttribute(input, 'data-group').length) {\n            if (nextSibling instanceof HTMLSpanElement) {\n                nextSibling.focus();\n            }\n        }\n    }\n\n    private onClear(e: React.MouseEvent<HTMLButtonElement>): void {\n        e.stopPropagation();\n\n        this.props.onClear();\n    }\n\n    private onToggle(e: React.SyntheticEvent<HTMLSpanElement>): void {\n        const { open, disabled, onToggle } = this.props;\n\n        if (disabled) {\n            return;\n        }\n\n        if (!this.searchInputs.some(inp => inp === e.target) || !open) {\n            onToggle();\n        }\n    }\n}\n"]}