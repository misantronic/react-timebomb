{"version":3,"sources":["src/value.tsx"],"names":["React","$fsx","r","styled_components_1","utils_1","button_1","Flex","default","div","Container","Input","span","ArrowButton","Button","ClearButton","Placeholder","Icon","WHITELIST_KEYS","keys","BACKSPACE","DELETE","TAB","exports","Value","PureComponent","[object Object]","props","super","this","searchInputs","onSearchRef","bind","onKeyDown","onKeyUp","onFocus","onBlur","onChange","onClear","onToggle","formatGroups","format","split","reduce","memo","char","prevChar","length","substr","focused","document","querySelector","prevProps","open","value","some","inp","parts","splitDate","input","forEach","i","innerText","focus","selectText","placeholder","showPlaceholder","createElement","data-role","className","onClick","renderValue","tabIndex","map","group","separator","contentEditable","data-placeholder","data-separator","key","data-group","ref","data-react-timebomb-selectable","el","range","createRange","sel","getSelection","selectNodeContents","removeAllRanges","addRange","push","e","onChangeValueText","allowValidation","currentTarget","nextSibling","previousSibling","hasSelection","Boolean","focusOffset","baseOffset","numericValue","parseInt","keyCode","ENTER","ESC","preventDefault","ARROW_RIGHT","HTMLSpanElement","ARROW_LEFT","ARROW_UP","ARROW_DOWN","isArrowUp","isNaN","isFinite","formatGroup","getAttribute","formatType","getFormatType","direction","newDate","manipulateDate","isEnabled","dateParts","nextValue","valid","validateFormatGroup","formatNumber","joinDates","dataValue","dataGroup","stringFromCharCode","groupValue","includes","metaKey","ctrlKey","blur","onSubmit","forbiddenKeys","SHIFT","setAttribute","target","fillZero","setTimeout","stopPropagation","undefined"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport styled from 'styled-components';\nimport {\n    keys,\n    formatNumber,\n    splitDate,\n    joinDates,\n    stringFromCharCode,\n    validateFormatGroup,\n    getAttribute,\n    getFormatType,\n    manipulateDate,\n    isEnabled\n} from './utils';\nimport { ReactTimebombProps } from './typings';\nimport { Button } from './button';\n\ninterface ValueProps {\n    open?: boolean;\n    value?: Date;\n    valueText?: string;\n    format: string;\n    placeholder: ReactTimebombProps['placeholder'];\n    minDate: ReactTimebombProps['minDate'];\n    maxDate: ReactTimebombProps['maxDate'];\n    allowValidation?: boolean;\n    onToggle(): void;\n    onChangeValueText(valueText?: string, commit?: boolean): void;\n    onSubmit(): void;\n}\n\nconst Flex = styled.div`\n    display: flex;\n    align-items: center;\n    white-space: nowrap;\n`;\n\nconst Container = styled(Flex)`\n    justify-content: space-between;\n    align-items: center;\n    padding: 5px 10px;\n    border: 1px solid #ccc;\n    cursor: pointer;\n    width: 100%;\n    height: 100%;\n    box-sizing: border-box;\n`;\n\nconst Input = styled.span`\n    padding: 2px 0 2px 0;\n    min-width: 1px;\n    cursor: text;\n\n    &:focus {\n        outline: none;\n    }\n\n    &:last-of-type {\n        padding: 2px 10px 2px 0;\n    }\n\n    &:not(:last-of-type):after {\n        content: attr(data-separator);\n        width: 4px;\n        display: inline-block;\n    }\n\n    &:empty:before {\n        content: attr(data-placeholder);\n        color: #aaa;\n    }\n\n    &:empty:not(:last-of-type):after {\n        color: #aaa;\n    }\n`;\n\nconst ArrowButton = styled(Button)`\n    font-size: 13px;\n    color: #ccc;\n    cursor: pointer;\n    border: none;\n    line-height: 1;\n\n    &:hover {\n        color: #333;\n    }\n\n    &:focus {\n        outline: none;\n    }\n`;\n\nconst ClearButton = styled(ArrowButton)`\n    font-size: 18px;\n`;\n\nconst Placeholder = styled.span`\n    color: #aaa;\n    user-select: none;\n`;\n\nconst Icon = styled.span`\n    margin-right: 5px;\n    user-select: none;\n\n    &:after {\n        content: 'ðŸ“…';\n    }\n`;\n\nconst WHITELIST_KEYS = [keys.BACKSPACE, keys.DELETE, keys.TAB];\n\nexport class Value extends React.PureComponent<ValueProps> {\n    private searchInputs: HTMLSpanElement[] = [];\n\n    private get formatGroups(): string[] {\n        return this.props.format.split('').reduce(\n            (memo, char) => {\n                const prevChar = memo[memo.length - 1];\n\n                if (prevChar && char === prevChar.substr(0, 1)) {\n                    memo[memo.length - 1] += char;\n                } else {\n                    memo = [...memo, char];\n                }\n\n                return memo;\n            },\n            [] as string[]\n        );\n    }\n\n    private get focused(): HTMLElement | null {\n        return document.querySelector(':focus');\n    }\n\n    constructor(props: ValueProps) {\n        super(props);\n\n        this.onSearchRef = this.onSearchRef.bind(this);\n        this.onKeyDown = this.onKeyDown.bind(this);\n        this.onKeyUp = this.onKeyUp.bind(this);\n        this.onFocus = this.onFocus.bind(this);\n        this.onBlur = this.onBlur.bind(this);\n        this.onChange = this.onChange.bind(this);\n        this.onClear = this.onClear.bind(this);\n        this.onToggle = this.onToggle.bind(this);\n    }\n\n    public componentDidUpdate(prevProps: ValueProps): void {\n        const { open, value, format } = this.props;\n        const hasFocus = this.searchInputs.some(inp => inp === this.focused);\n\n        if (!hasFocus) {\n            if (prevProps.value !== value && value) {\n                const parts = splitDate(value, format);\n                const input = this.searchInputs[0];\n\n                this.searchInputs.forEach(\n                    (input, i) => (input.innerText = parts[i])\n                );\n\n                if (input) {\n                    input.focus();\n                }\n            }\n\n            if ((open && !prevProps.open) || value !== prevProps.value) {\n                const input = this.searchInputs[0];\n\n                if (input) {\n                    if (input.innerText === '') {\n                        input.focus();\n                    } else {\n                        this.selectText(input);\n                    }\n                }\n            }\n        }\n\n        if (!open && value) {\n            const parts = splitDate(value, format);\n\n            this.searchInputs.forEach(\n                (input, i) => (input.innerText = parts[i])\n            );\n        }\n    }\n\n    public render(): React.ReactNode {\n        const { placeholder, value, open } = this.props;\n        const showPlaceholder = placeholder && !open;\n\n        return (\n            <Container\n                data-role=\"value\"\n                className=\"react-slct-value react-timebomb-value\"\n                onClick={this.onToggle}\n            >\n                <Flex>\n                    <Icon className=\"react-timebomb-icon\" />\n                    <Flex>\n                        {this.renderValue()}\n                        {showPlaceholder && (\n                            <Placeholder className=\"react-timebomb-placeholder\">\n                                {placeholder}\n                            </Placeholder>\n                        )}\n                    </Flex>\n                </Flex>\n                <Flex>\n                    {value && (\n                        <ClearButton\n                            className=\"react-timebomb-clearer\"\n                            tabIndex={-1}\n                            onClick={this.onClear}\n                        >\n                            Ã—\n                        </ClearButton>\n                    )}\n                    <ArrowButton tabIndex={-1} className=\"react-timebomb-arrow\">\n                        {open ? 'â–²' : 'â–¼'}\n                    </ArrowButton>\n                </Flex>\n            </Container>\n        );\n    }\n\n    private renderValue(): React.ReactNode {\n        const { open, value } = this.props;\n\n        if (!open && !value) {\n            return null;\n        }\n\n        const { formatGroups } = this;\n\n        return (\n            <Flex>\n                {formatGroups.map((group, i) => {\n                    if (group === '.' || group === ':' || group === ' ') {\n                        return null;\n                    } else {\n                        const separator = formatGroups[i + 1];\n\n                        return (\n                            <Input\n                                contentEditable\n                                data-placeholder={group}\n                                data-separator={separator}\n                                key={group}\n                                data-group={group}\n                                ref={this.onSearchRef}\n                                data-react-timebomb-selectable\n                                onKeyDown={this.onKeyDown}\n                                onKeyUp={this.onKeyUp}\n                                onFocus={this.onFocus}\n                                onBlur={this.onBlur}\n                                onClick={this.onFocus}\n                                onChange={this.onChange}\n                            />\n                        );\n                    }\n                })}\n            </Flex>\n        );\n    }\n\n    private selectText(el: HTMLElement | undefined) {\n        if (el) {\n            const range = document.createRange();\n            const sel = getSelection();\n\n            range.selectNodeContents(el);\n\n            sel.removeAllRanges();\n            sel.addRange(range);\n        }\n    }\n\n    private onSearchRef(el: HTMLSpanElement | null): void {\n        if (el) {\n            this.searchInputs.push(el);\n        } else {\n            this.searchInputs = [];\n        }\n    }\n\n    private onKeyDown(e: React.KeyboardEvent<HTMLSpanElement>): void {\n        const {\n            onChangeValueText,\n            format,\n            value,\n            allowValidation\n        } = this.props;\n        const input = e.currentTarget;\n        const { innerText, nextSibling, previousSibling } = input;\n        const sel = getSelection();\n        const hasSelection = Boolean(sel.focusOffset - sel.baseOffset);\n        let numericValue = parseInt(innerText, 10);\n\n        switch (e.keyCode) {\n            case keys.ENTER:\n            case keys.ESC:\n                e.preventDefault();\n                return;\n            case keys.ARROW_RIGHT:\n                e.preventDefault();\n\n                if (nextSibling instanceof HTMLSpanElement) {\n                    nextSibling.focus();\n                } else {\n                    this.selectText(input);\n                }\n                return;\n            case keys.ARROW_LEFT:\n                e.preventDefault();\n\n                if (previousSibling instanceof HTMLSpanElement) {\n                    previousSibling.focus();\n                } else {\n                    this.selectText(input);\n                }\n                return;\n            case keys.ARROW_UP:\n            case keys.ARROW_DOWN:\n                e.preventDefault();\n\n                const isArrowUp = e.keyCode === keys.ARROW_UP;\n\n                if (isNaN(numericValue)) {\n                    numericValue = 0;\n                }\n\n                if (isFinite(numericValue)) {\n                    const formatGroup = getAttribute(input, 'data-group');\n                    const formatType = getFormatType(formatGroup);\n\n                    if (!allowValidation) {\n                        const nextValue = numericValue + (isArrowUp ? 1 : -1);\n                        const valid = validateFormatGroup(\n                            nextValue,\n                            formatGroup\n                        );\n\n                        if (valid) {\n                            input.innerText =\n                                typeof valid === 'string'\n                                    ? valid\n                                    : formatNumber(nextValue);\n                        }\n                    } else {\n                        if (value && formatType) {\n                            const direction = isArrowUp ? 'add' : 'subtract';\n\n                            const newDate = manipulateDate(\n                                value,\n                                formatType,\n                                direction\n                            );\n                            const enabled = isEnabled(\n                                'day',\n                                newDate,\n                                this.props\n                            );\n\n                            if (enabled) {\n                                const dateParts = splitDate(newDate, format);\n\n                                this.searchInputs.map(\n                                    (inp, i) => (inp.innerText = dateParts[i])\n                                );\n                            }\n                        }\n                    }\n\n                    this.selectText(input);\n                    onChangeValueText(joinDates(this.searchInputs, format));\n                }\n                return;\n        }\n\n        const dataValue = getAttribute(input, 'data-value');\n        const dataGroup = getAttribute(input, 'data-group');\n        const char = stringFromCharCode(e.keyCode);\n        const groupValue = dataValue && !hasSelection ? dataValue + char : char;\n\n        if (WHITELIST_KEYS.includes(e.keyCode) || e.metaKey || e.ctrlKey) {\n            return;\n        }\n\n        const valid = validateFormatGroup(groupValue, dataGroup);\n\n        if (!valid) {\n            e.preventDefault();\n        } else if (typeof valid === 'string') {\n            e.preventDefault();\n\n            input.innerText = valid;\n        }\n\n        if (hasSelection) {\n            return;\n        }\n\n        // validate group\n        if (innerText.length >= dataGroup.length) {\n            e.preventDefault();\n        }\n    }\n\n    private onKeyUp(e: React.KeyboardEvent<HTMLSpanElement>): void {\n        const { onChangeValueText, format, allowValidation } = this.props;\n        const input = e.currentTarget;\n        const { innerText, nextSibling } = input;\n\n        if (e.keyCode === keys.ENTER) {\n            e.preventDefault();\n\n            if (this.focused) {\n                this.focused.blur();\n            }\n            this.props.onSubmit();\n\n            return;\n        }\n\n        if (e.keyCode === keys.ESC) {\n            this.props.onToggle();\n\n            return;\n        }\n\n        const forbiddenKeys = [\n            keys.SHIFT,\n            keys.ARROW_LEFT,\n            keys.ARROW_RIGHT,\n            keys.ARROW_UP,\n            keys.ARROW_DOWN,\n            keys.TAB\n        ];\n\n        // focus next\n        if (\n            innerText.length >= getAttribute(input, 'data-group').length &&\n            !forbiddenKeys.includes(e.keyCode)\n        ) {\n            if (allowValidation || !nextSibling) {\n                this.selectText(input);\n            } else if (nextSibling instanceof HTMLSpanElement) {\n                this.selectText(nextSibling);\n            }\n\n            onChangeValueText(joinDates(this.searchInputs, format));\n        }\n\n        input.setAttribute('data-value', innerText);\n    }\n\n    private onFocus(e: React.SyntheticEvent<HTMLSpanElement>): void {\n        this.selectText(e.currentTarget);\n    }\n\n    private onBlur(e: React.SyntheticEvent<HTMLSpanElement>): void {\n        const input = e.target as HTMLSpanElement;\n        const value = input.innerText;\n        const dataGroup = getAttribute(input, 'data-group');\n        const formatType = getFormatType(dataGroup);\n\n        const fillZero = () => {\n            const innerText = `0${value}`;\n\n            input.innerText = innerText;\n            input.setAttribute('data-value', innerText);\n        };\n\n        switch (formatType) {\n            case 'day':\n                if (value === '1' || value === '2' || value === '3') {\n                    fillZero();\n                }\n                break;\n            case 'month':\n                if (value === '1') {\n                    fillZero();\n                }\n                break;\n        }\n\n        // check if timebomb is still focused\n        setTimeout(() => {\n            const { focused } = this;\n\n            if (\n                this.props.open &&\n                focused &&\n                !focused.getAttribute('data-react-timebomb-selectable')\n            ) {\n                this.props.onToggle();\n            }\n        }, 0);\n    }\n\n    private onChange(e: React.KeyboardEvent<HTMLSpanElement>): void {\n        const { format, onChangeValueText } = this.props;\n        const input = e.currentTarget;\n        const { innerText, nextSibling } = input;\n\n        onChangeValueText(joinDates(this.searchInputs, format));\n\n        if (innerText.length >= getAttribute(input, 'data-group').length) {\n            if (nextSibling instanceof HTMLSpanElement) {\n                nextSibling.focus();\n            }\n        }\n    }\n\n    private onClear(e: React.SyntheticEvent<HTMLButtonElement>): void {\n        e.stopPropagation();\n\n        this.props.onChangeValueText(undefined, true);\n    }\n\n    private onToggle(e: React.SyntheticEvent<HTMLSpanElement>): void {\n        const { open, onToggle } = this.props;\n\n        if (!this.searchInputs.some(inp => inp === e.target) || !open) {\n            onToggle();\n        }\n    }\n}\n"]}