{"version":3,"sources":["src/utils.ts","src/value.tsx"],"names":["moment_1","$fsx","r","momentImport","moment","default","formatSplit","dateFormat","date","format","isArray","map","getFormatType","test","exports","validateDate","dates","instance","isValid","toDate","undefined","filter","d","Boolean","length","validateFormatGroup","input","isFinite","int","parseInt","char","String","strLen","startsWith","ALLOWED_CHARS","startOfDay","newDate","Date","setHours","addDays","num","add","Array","val","stringFromCharCode","keyCode","charCode","Math","floor","fromCharCode","includes","formatNumber","number","splitDate","split","joinDates","parts","strParts","part","HTMLElement","innerText","splittedFormat","join","spaceFormat","momentDate","parsingFlags","overflow","parsedDateParts","clearSelection","sel","getSelection","empty","removeAllRanges","getWeekOfYear","isoWeek","startOfWeek","startOf","endOfWeek","endOf","endOfDay","subtractDays","manipulateDate","subtract","isSame","isBefore","inp","isAfter","dateA","isEnabled","isSameOrAfter","minDate","context","getAttribute","attr","isDateFormat","isTimeFormat","a","b","getTime","keys","ARROW_UP","ARROW_RIGHT","ARROW_DOWN","ARROW_LEFT","ENTER","TAB","ESC","BACKSPACE","DELETE","SPACE","SHIFT","DOT","COMMA","React","styled_components_1","utils_1","button_1","arrow_button_1","Flex","div","Container","props","disabled","Input","span","ClearButton","SmallButton","Placeholder","Icon","icon","META_KEYS","FORBIDDEN_KEYS","Value","PureComponent","[object Object]","super","this","inputs","state","onSearchRef","bind","onKeyDown","onKeyUp","onFocus","onClick","onDblClick","onBlur","onChange","onClear","onToggle","formatGroups","reduce","memo","prevChar","substr","focused","document","querySelector","iconClass","showTime","showDate","prevProps","open","value","some","forEach","i","focus","selectText","setState","allSelected","forceUpdate","placeholder","ArrowButtonComp","arrowButtonComponent","ArrowButton","showPlaceholder","timeOnly","createElement","data-role","className","renderValue","tabIndex","group","separator","contentEditable","data-placeholder","data-separator","key","data-group","ref","data-react-timebomb-selectable","onDoubleClick","el","range","createRange","selectNodeContents","addRange","push","e","onChangeValueText","allowValidation","currentTarget","nextSibling","previousSibling","hasSelection","focusOffset","baseOffset","numericValue","preventDefault","HTMLSpanElement","isArrowUp","isNaN","formatGroup","formatType","direction","shiftKey","dateParts","nextValue","valid","dataGroup","groupValue","metaKey","ctrlKey","onSubmit","blur","parentNode","target","fillZero","setTimeout","stopPropagation"],"mappings":"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","sourcesContent":["// @ts-ignore\nimport momentDefaultImport from 'moment';\nimport * as momentImport from 'moment';\nimport { ReactTimebombDate } from './typings';\n\nconst moment: typeof momentImport = momentDefaultImport || momentImport;\nconst formatSplit = /[.|:|-|\\\\|_|\\s]/;\n\ntype FormatType = 'day' | 'month' | 'year' | 'hour' | 'minute' | 'second';\n\nexport function dateFormat(\n    date: ReactTimebombDate,\n    format: string\n): string | string[] {\n    if (isArray(date)) {\n        return date.map(date => moment(date).format(format));\n    } else {\n        return moment(date).format(format);\n    }\n}\n\nexport function validateDate(\n    date: string | string[] | undefined,\n    format: string\n): ReactTimebombDate {\n    if (isArray(date)) {\n        const dates = date\n            .map(date => {\n                const instance = moment(date, format, true);\n\n                return instance.isValid() ? instance.toDate() : undefined;\n            })\n            .filter(d => Boolean(d)) as Date[];\n\n        return dates.length === 0 ? undefined : dates;\n    } else {\n        const instance = moment(date, format, true);\n\n        return instance.isValid() ? instance.toDate() : undefined;\n    }\n}\n\nexport function getFormatType(format: string): FormatType | undefined {\n    if (/d/i.test(format)) {\n        return 'day';\n    }\n\n    if (/M/.test(format)) {\n        return 'month';\n    }\n\n    if (/y/i.test(format)) {\n        return 'year';\n    }\n\n    if (/h/i.test(format)) {\n        return 'hour';\n    }\n\n    if (/m/.test(format)) {\n        return 'minute';\n    }\n\n    if (/s/.test(format)) {\n        return 'second';\n    }\n\n    return undefined;\n}\n\n/** @return returns a string with transformed value, true for valid input or false for invalid input */\nexport function validateFormatGroup(\n    input: string | number,\n    format: string\n): boolean | string {\n    if (isFinite(input as any)) {\n        const int = typeof input === 'string' ? parseInt(input, 10) : input;\n        const char = String(input);\n        const strLen = char.length;\n        const type = getFormatType(format);\n\n        switch (type) {\n            case 'day':\n                if (strLen === 1) {\n                    if (int >= 0 && int <= 3) {\n                        return true;\n                    } else {\n                        return `0${input}`;\n                    }\n                }\n\n                if (strLen === 2 && int >= 1 && int <= 31) {\n                    return true;\n                }\n                break;\n            case 'month':\n                if (strLen === 1) {\n                    if (int === 0 || int === 1) {\n                        return true;\n                    } else {\n                        return `0${input}`;\n                    }\n                }\n\n                if (strLen === 2 && int >= 0 && int <= 12) {\n                    return true;\n                }\n                break;\n            case 'year':\n                if (strLen === 1 && (int === 1 || int === 2)) {\n                    return true;\n                }\n\n                if (\n                    strLen >= 2 &&\n                    (char.startsWith('19') || char.startsWith('20'))\n                ) {\n                    return true;\n                }\n                break;\n            case 'hour':\n                if (strLen === 1) {\n                    if (int >= 0 && int <= 2) {\n                        return true;\n                    } else {\n                        return `0${input}`;\n                    }\n                }\n\n                if (strLen >= 2 && int >= 0 && int <= 24) {\n                    return true;\n                }\n                break;\n            case 'minute':\n            case 'second':\n                if (strLen === 1) {\n                    if (int >= 0 && int <= 5) {\n                        return true;\n                    } else {\n                        return `0${input}`;\n                    }\n                }\n\n                if (strLen >= 2 && int >= 0 && int <= 59) {\n                    return true;\n                }\n                break;\n        }\n    }\n\n    return false;\n}\n\nconst ALLOWED_CHARS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n\nexport function stringFromCharCode(keyCode: number): string {\n    const charCode = keyCode - 48 * Math.floor(keyCode / 48);\n    const char = String.fromCharCode(96 <= keyCode ? charCode : keyCode);\n\n    if (ALLOWED_CHARS.includes(char)) {\n        return char;\n    }\n\n    return '';\n}\n\nexport function formatNumber(number: Number): string {\n    if (number <= 1) {\n        return '01';\n    }\n\n    if (number <= 9) {\n        return `0${number}`;\n    }\n\n    return String(number);\n}\n\nexport function splitDate(date: Date, format: string): string[] {\n    return (dateFormat(date, format) as string).split(formatSplit);\n}\n\nexport function joinDates(\n    parts: (string | HTMLElement)[],\n    format: string\n): string {\n    const strParts = parts\n        .map(part => (part instanceof HTMLElement ? part.innerText : part))\n        .filter(val => val);\n    const splittedFormat = format.split(formatSplit);\n\n    if (strParts.length !== splittedFormat.length) {\n        return '';\n    }\n\n    const date = strParts.join(' ');\n    const spaceFormat = splittedFormat.join(' ');\n    const momentDate = moment(date, spaceFormat);\n    const parsingFlags = momentDate.parsingFlags();\n\n    if (parsingFlags.overflow === 2) {\n        return moment(\n            // @ts-ignore\n            new Date(...parsingFlags.parsedDateParts)\n        ).format(format);\n    }\n\n    return momentDate.format(format);\n}\n\nexport function clearSelection(): void {\n    const sel = getSelection();\n\n    if (sel.empty) {\n        // Chrome\n        sel.empty();\n    } else if (sel.removeAllRanges) {\n        // Firefox\n        sel.removeAllRanges();\n    }\n}\n\nexport function getWeekOfYear(date: Date): number {\n    return moment(date).isoWeek();\n}\n\nexport function startOfWeek(date: Date): Date {\n    return moment(date)\n        .startOf('isoWeek')\n        .toDate();\n}\n\nexport function endOfWeek(date: Date): Date {\n    return moment(date)\n        .endOf('isoWeek')\n        .toDate();\n}\n\nexport function startOfDay(date: Date): Date {\n    const newDate = new Date(date);\n\n    newDate.setHours(0, 0, 0, 0);\n\n    return newDate;\n}\n\nexport function endOfDay(date: Date): Date {\n    const newDate = new Date(date);\n\n    newDate.setHours(23, 59, 59, 999);\n\n    return newDate;\n}\n\nexport function addDays(date: Date, num: number): Date {\n    return moment(date)\n        .add(num, 'days')\n        .toDate();\n}\n\nexport function addMonths(date: Date, num: number): Date {\n    return moment(date)\n        .add(num, 'months')\n        .toDate();\n}\n\nexport function addYears(date: Date, num: number): Date {\n    return moment(date)\n        .add(num, 'years')\n        .toDate();\n}\n\nexport function addHours(date: Date, num: number): Date {\n    return moment(date)\n        .add(num, 'hours')\n        .toDate();\n}\n\nexport function addMinutes(date: Date, num: number): Date {\n    return moment(date)\n        .add(num, 'minutes')\n        .toDate();\n}\n\nexport function addSeconds(date: Date, num: number): Date {\n    return moment(date)\n        .add(num, 'seconds')\n        .toDate();\n}\n\nexport function subtractSeconds(date: Date, num: number): Date {\n    return moment(date)\n        .subtract(num, 'seconds')\n        .toDate();\n}\n\nexport function subtractMinutes(date: Date, num: number): Date {\n    return moment(date)\n        .subtract(num, 'minutes')\n        .toDate();\n}\n\nexport function subtractHours(date: Date, num: number): Date {\n    return moment(date)\n        .subtract(num, 'hours')\n        .toDate();\n}\n\nexport function subtractDays(date: Date, num: number): Date {\n    return moment(date)\n        .subtract(num, 'days')\n        .toDate();\n}\n\nexport function subtractMonths(date: Date, num: number): Date {\n    return moment(date)\n        .subtract(num, 'months')\n        .toDate();\n}\n\nexport function subtractYears(date: Date, num: number): Date {\n    return moment(date)\n        .subtract(num, 'years')\n        .toDate();\n}\n\nexport function manipulateDate(\n    date: Date,\n    formatType: FormatType,\n    direction: 'add' | 'subtract',\n    shift = false\n): Date {\n    switch (formatType) {\n        case 'day':\n            if (direction === 'add') return addDays(date, 1);\n            if (direction === 'subtract') return subtractDays(date, 1);\n            break;\n        case 'month':\n            if (direction === 'add') return addMonths(date, 1);\n            if (direction === 'subtract') return subtractMonths(date, 1);\n            break;\n        case 'year':\n            if (direction === 'add') return addYears(date, 1);\n            if (direction === 'subtract') return subtractYears(date, 1);\n            break;\n        case 'hour':\n            if (direction === 'add') return addHours(date, shift ? 10 : 1);\n            if (direction === 'subtract')\n                return subtractHours(date, shift ? 10 : 1);\n            break;\n        case 'minute':\n            if (direction === 'add') return addMinutes(date, shift ? 10 : 1);\n            if (direction === 'subtract')\n                return subtractMinutes(date, shift ? 10 : 1);\n            break;\n        case 'second':\n            if (direction === 'add') return addSeconds(date, shift ? 10 : 1);\n            if (direction === 'subtract')\n                return subtractSeconds(date, shift ? 10 : 1);\n            break;\n    }\n\n    return new Date();\n}\n\nexport function startOfMonth(date: Date): Date {\n    const newDate = new Date(date);\n\n    newDate.setDate(1);\n    newDate.setHours(0, 0, 0, 0);\n\n    return newDate;\n}\n\nexport function endOfMonth(date: Date): Date {\n    return new Date(date.getFullYear(), date.getMonth() + 1, 0);\n}\n\nexport function isUndefined(val): val is undefined {\n    return val === null || val === undefined;\n}\n\nexport function setDate(date: Date, hour: number, min?: number): Date {\n    const newDate = new Date(date);\n\n    newDate.setHours(hour, min);\n\n    return newDate;\n}\n\nexport function isToday(date: Date): boolean {\n    return moment(date).isSame(new Date(), 'day');\n}\n\nexport function isBefore(date: Date, inp: Date) {\n    return moment(date).isBefore(inp, 'day');\n}\n\nexport function isAfter(date: Date, inp: Date) {\n    return moment(date).isAfter(inp, 'day');\n}\n\nexport function dateEqual(\n    dateA?: ReactTimebombDate,\n    dateB?: ReactTimebombDate,\n    considerTime = false\n) {\n    if (!dateA || !dateB) {\n        return false;\n    }\n\n    if (considerTime) {\n        if (isArray(dateA)) {\n            dateA = dateA.map(startOfDay);\n        } else {\n            dateA = startOfDay(dateA);\n        }\n\n        if (isArray(dateB)) {\n            dateB = dateB.map(startOfDay);\n        } else {\n            dateB = startOfDay(dateB);\n        }\n    }\n\n    if (isArray(dateA) && isArray(dateB)) {\n        return dateA.every((date, i) => {\n            const dBi = dateB![i];\n\n            if (date && dBi) {\n                return date.getTime() === dBi.getTime();\n            }\n\n            return false;\n        });\n    } else if (isArray(dateA) && dateB instanceof Date) {\n        return dateA.some(d => d.getTime() === (dateB as Date).getTime());\n    } else if (isArray(dateB) && dateA instanceof Date) {\n        return dateB.some(d => d.getTime() === (dateA as Date).getTime());\n    } else if (!isArray(dateA) && !isArray(dateB)) {\n        return dateA.getTime() === dateB.getTime();\n    }\n\n    return false;\n}\n\nexport function getMonthNames(short?: boolean): string[] {\n    if (short) {\n        return moment.monthsShort();\n    }\n\n    return moment.months();\n}\n\nexport function isEnabled(\n    context: 'year' | 'month' | 'day',\n    date: Date,\n    { minDate, maxDate }: { minDate?: Date; maxDate?: Date }\n): boolean {\n    if (!minDate && !maxDate) {\n        return true;\n    }\n\n    if (minDate && !maxDate) {\n        return moment(date).isSameOrAfter(minDate, context);\n    }\n\n    if (!minDate && maxDate) {\n        return moment(date).isSameOrBefore(maxDate, context);\n    }\n\n    return moment(date).isBetween(minDate, maxDate, context, '[]');\n}\n\nexport function getAttribute(input: Element, attr: string): string {\n    return input.getAttribute(attr)!;\n}\n\nexport function isDateFormat(format: string) {\n    return Boolean(/D|M|Y/.test(format));\n}\n\nexport function isTimeFormat(format: string) {\n    return Boolean(/H|h|m|k|a|S|s/.test(format));\n}\n\nexport function sortDates(a: Date, b: Date) {\n    return a.getTime() - b.getTime();\n}\n\nexport function isArray(val: any): val is any[] {\n    return Array.isArray(val);\n}\n\nexport const keys = {\n    ARROW_UP: 38,\n    ARROW_RIGHT: 39,\n    ARROW_DOWN: 40,\n    ARROW_LEFT: 37,\n    ENTER: 13,\n    TAB: 9,\n    ESC: 27,\n    BACKSPACE: 8,\n    DELETE: 46,\n    SPACE: 32,\n    SHIFT: 16,\n    DOT: 190,\n    COMMA: 188\n};\n","import * as React from 'react';\nimport styled from 'styled-components';\nimport {\n    keys,\n    formatNumber,\n    splitDate,\n    joinDates,\n    stringFromCharCode,\n    validateFormatGroup,\n    getAttribute,\n    getFormatType,\n    manipulateDate,\n    isEnabled\n} from './utils';\nimport { ReactTimebombProps, ReactTimebombState } from './typings';\nimport { SmallButton } from './button';\nimport { ArrowButton } from './arrow-button';\n\nexport interface ValueProps {\n    open?: boolean;\n    value?: Date;\n    format: string;\n    placeholder: ReactTimebombProps['placeholder'];\n    minDate: ReactTimebombProps['minDate'];\n    maxDate: ReactTimebombProps['maxDate'];\n    showDate: ReactTimebombState['showDate'];\n    showTime: ReactTimebombState['showTime'];\n    allowValidation: ReactTimebombState['allowValidation'];\n    arrowButtonComponent: ReactTimebombProps['arrowButtonComponent'];\n    disabled: ReactTimebombProps['disabled'];\n    onToggle(): void;\n    onChangeValueText(valueText?: string, commit?: boolean): void;\n    onSubmit(): void;\n    onClear(): void;\n}\n\ninterface ValueState {\n    allSelected?: boolean;\n}\n\ninterface InputProps {\n    disabled?: boolean;\n}\n\nexport const Flex = styled.div`\n    display: flex;\n    align-items: center;\n    white-space: nowrap;\n    position: relative;\n`;\n\nexport const Container = styled(Flex)`\n    justify-content: space-between;\n    align-items: center;\n    padding: 5px 10px;\n    border: 1px solid #ccc;\n    cursor: ${(props: { disabled?: boolean }) =>\n        props.disabled ? 'not-allowed' : 'pointer'};\n    width: 100%;\n    height: 100%;\n    box-sizing: border-box;\n`;\n\nconst Input = styled.span`\n    padding: 2px 0 2px 0;\n    min-width: 1px;\n    cursor: ${(props: InputProps) => (props.disabled ? 'not-allowed' : 'text')};\n    pointer-events: ${(props: InputProps) =>\n        props.disabled ? 'none' : 'auto'};\n\n    &:focus {\n        outline: none;\n    }\n\n    &:last-of-type {\n        padding: 2px 10px 2px 0;\n    }\n\n    &:not(:last-of-type):after {\n        content: attr(data-separator);\n        width: 4px;\n        display: inline-block;\n    }\n\n    &:empty:before {\n        content: attr(data-placeholder);\n        color: #aaa;\n    }\n\n    &:empty:not(:last-of-type):after {\n        color: #aaa;\n    }\n`;\n\nexport const ClearButton = styled(SmallButton)`\n    font-size: 18px;\n`;\n\nexport const Placeholder = styled.span`\n    color: #aaa;\n    user-select: none;\n`;\n\nexport const Icon = styled.span`\n    margin-right: 5px;\n    user-select: none;\n\n    &:after {\n        content: '${(props: { icon: string }) => props.icon}';\n    }\n`;\n\nconst META_KEYS = [keys.BACKSPACE, keys.DELETE, keys.TAB];\n\nconst FORBIDDEN_KEYS = [\n    keys.SHIFT,\n    keys.ARROW_LEFT,\n    keys.ARROW_RIGHT,\n    keys.ARROW_UP,\n    keys.ARROW_DOWN,\n    keys.TAB\n];\n\nexport class Value extends React.PureComponent<ValueProps, ValueState> {\n    private inputs: HTMLSpanElement[] = [];\n\n    private get formatGroups(): string[] {\n        return this.props.format.split('').reduce(\n            (memo, char) => {\n                const prevChar = memo[memo.length - 1];\n\n                if (prevChar && char === prevChar.substr(0, 1)) {\n                    memo[memo.length - 1] += char;\n                } else {\n                    memo = [...memo, char];\n                }\n\n                return memo;\n            },\n            [] as string[]\n        );\n    }\n\n    private get focused(): HTMLElement | null {\n        return document.querySelector(':focus');\n    }\n\n    private get iconClass(): 'time' | 'calendar' {\n        const { showTime, showDate } = this.props;\n\n        if (!showDate && showTime) {\n            return 'time';\n        }\n\n        return 'calendar';\n    }\n\n    private get icon() {\n        switch (this.iconClass) {\n            case 'calendar':\n                return '📅';\n            case 'time':\n                return '⏱';\n        }\n    }\n\n    constructor(props: ValueProps) {\n        super(props);\n\n        this.state = {};\n\n        this.onSearchRef = this.onSearchRef.bind(this);\n        this.onKeyDown = this.onKeyDown.bind(this);\n        this.onKeyUp = this.onKeyUp.bind(this);\n        this.onFocus = this.onFocus.bind(this);\n        this.onClick = this.onClick.bind(this);\n        this.onDblClick = this.onDblClick.bind(this);\n        this.onBlur = this.onBlur.bind(this);\n        this.onChange = this.onChange.bind(this);\n        this.onClear = this.onClear.bind(this);\n        this.onToggle = this.onToggle.bind(this);\n    }\n\n    public componentDidUpdate(prevProps: ValueProps): void {\n        const { open, value, format } = this.props;\n        const hasFocus = this.inputs.some(inp => inp === this.focused);\n\n        if (!hasFocus) {\n            if (open) {\n                if (prevProps.value !== value && value) {\n                    const parts = splitDate(value, format);\n                    const input = this.inputs[0];\n\n                    this.inputs.forEach(\n                        (input, i) => (input.innerText = parts[i])\n                    );\n\n                    if (input) {\n                        input.focus();\n                    }\n                }\n\n                if (!prevProps.open || value !== prevProps.value) {\n                    const [input] = this.inputs;\n\n                    if (input) {\n                        this.selectText(input);\n                    }\n                }\n            }\n        }\n\n        if (!open && value) {\n            const parts = splitDate(value, format);\n\n            this.inputs.forEach((input, i) => (input.innerText = parts[i]));\n        }\n\n        if (!open) {\n            this.setState({ allSelected: false });\n        }\n    }\n\n    public componentDidMount() {\n        if (this.props.value) {\n            this.forceUpdate();\n        }\n    }\n\n    public render(): React.ReactNode {\n        const {\n            placeholder,\n            value,\n            showDate,\n            showTime,\n            disabled,\n            open\n        } = this.props;\n        const ArrowButtonComp = this.props.arrowButtonComponent || ArrowButton;\n        const showPlaceholder = placeholder && !open;\n        const timeOnly = showTime && !showDate;\n\n        return (\n            <Container\n                data-role=\"value\"\n                className=\"react-slct-value react-timebomb-value\"\n                disabled={disabled}\n                onClick={this.onToggle}\n            >\n                <Flex>\n                    <Icon\n                        icon={this.icon}\n                        className={`react-timebomb-icon ${this.iconClass}`}\n                    />\n                    <Flex>\n                        {this.renderValue()}\n                        {showPlaceholder && (\n                            <Placeholder className=\"react-timebomb-placeholder\">\n                                {placeholder}\n                            </Placeholder>\n                        )}\n                    </Flex>\n                </Flex>\n                <Flex>\n                    {value && (\n                        <ClearButton\n                            className=\"react-timebomb-clearer\"\n                            tabIndex={-1}\n                            disabled={disabled}\n                            onClick={this.onClear}\n                        >\n                            ×\n                        </ClearButton>\n                    )}\n                    {!timeOnly && (\n                        <ArrowButtonComp disabled={disabled} open={open} />\n                    )}\n                </Flex>\n            </Container>\n        );\n    }\n\n    private renderValue(): React.ReactNode {\n        const { open, disabled, value } = this.props;\n\n        if (!open && !value) {\n            return null;\n        }\n\n        const { formatGroups } = this;\n\n        return (\n            <Flex>\n                {formatGroups.map((group, i) => {\n                    if (group === '.' || group === ':' || group === ' ') {\n                        return null;\n                    } else {\n                        const separator = formatGroups[i + 1];\n\n                        return (\n                            <Input\n                                contentEditable={!disabled}\n                                disabled={disabled}\n                                data-placeholder={group}\n                                data-separator={separator}\n                                key={group}\n                                data-group={group}\n                                ref={this.onSearchRef}\n                                data-react-timebomb-selectable\n                                onKeyDown={this.onKeyDown}\n                                onKeyUp={this.onKeyUp}\n                                onFocus={this.onFocus}\n                                onBlur={this.onBlur}\n                                onClick={this.onClick}\n                                onDoubleClick={this.onDblClick}\n                                onChange={this.onChange}\n                            />\n                        );\n                    }\n                })}\n            </Flex>\n        );\n    }\n\n    private selectText(el: HTMLElement | undefined) {\n        if (el) {\n            const range = document.createRange();\n            const sel = getSelection();\n\n            range.selectNodeContents(el);\n\n            sel.removeAllRanges();\n            sel.addRange(range);\n        }\n    }\n\n    private onSearchRef(el: HTMLSpanElement | null): void {\n        if (el) {\n            this.inputs.push(el);\n        } else {\n            this.inputs = [];\n        }\n    }\n\n    private onKeyDown(e: React.KeyboardEvent<HTMLSpanElement>): void {\n        const {\n            onChangeValueText,\n            format,\n            value,\n            allowValidation\n        } = this.props;\n        const input = e.currentTarget;\n        const { innerText, nextSibling, previousSibling } = input;\n        const sel = getSelection();\n        const hasSelection = Boolean(sel.focusOffset - sel.baseOffset);\n        let numericValue = parseInt(innerText, 10);\n\n        switch (e.keyCode) {\n            case keys.ENTER:\n            case keys.ESC:\n            case keys.BACKSPACE:\n            case keys.DOT:\n            case keys.COMMA:\n                e.preventDefault();\n                return;\n            case keys.ARROW_RIGHT:\n                e.preventDefault();\n\n                if (nextSibling instanceof HTMLSpanElement) {\n                    nextSibling.focus();\n                } else {\n                    this.selectText(input);\n                }\n                return;\n            case keys.ARROW_LEFT:\n                e.preventDefault();\n\n                if (previousSibling instanceof HTMLSpanElement) {\n                    previousSibling.focus();\n                } else {\n                    this.selectText(input);\n                }\n                return;\n            case keys.ARROW_UP:\n            case keys.ARROW_DOWN:\n                e.preventDefault();\n\n                const isArrowUp = e.keyCode === keys.ARROW_UP;\n\n                if (isNaN(numericValue)) {\n                    numericValue = 0;\n                }\n\n                if (isFinite(numericValue)) {\n                    const formatGroup = getAttribute(input, 'data-group');\n                    const formatType = getFormatType(formatGroup);\n\n                    if (!allowValidation) {\n                        const add = e.shiftKey ? 10 : 1;\n                        const nextValue =\n                            numericValue + (isArrowUp ? add : -add);\n                        const valid = validateFormatGroup(\n                            nextValue,\n                            formatGroup\n                        );\n\n                        if (valid) {\n                            input.innerText =\n                                typeof valid === 'string'\n                                    ? valid\n                                    : formatNumber(nextValue);\n                        }\n                    } else {\n                        if (value && formatType) {\n                            const direction = isArrowUp ? 'add' : 'subtract';\n\n                            const newDate = manipulateDate(\n                                value,\n                                formatType,\n                                direction,\n                                e.shiftKey\n                            );\n                            const enabled = isEnabled(\n                                'day',\n                                newDate,\n                                this.props\n                            );\n\n                            if (enabled) {\n                                const dateParts = splitDate(newDate, format);\n\n                                this.inputs.map(\n                                    (inp, i) => (inp.innerText = dateParts[i])\n                                );\n                            }\n                        }\n                    }\n\n                    this.selectText(input);\n                    onChangeValueText(joinDates(this.inputs, format));\n                }\n                return;\n        }\n\n        const dataGroup = getAttribute(input, 'data-group');\n        const char = stringFromCharCode(e.keyCode);\n        const groupValue = innerText && !hasSelection ? innerText + char : char;\n\n        if (META_KEYS.includes(e.keyCode) || e.metaKey || e.ctrlKey) {\n            return;\n        }\n\n        const valid = validateFormatGroup(groupValue, dataGroup);\n\n        if (!valid) {\n            e.preventDefault();\n        } else if (typeof valid === 'string') {\n            e.preventDefault();\n\n            input.innerText = valid;\n        }\n\n        // TODO: this doesn't work quite how suppossed to\n        // if (this.state.allSelected) {\n        //     const char = stringFromCharCode(e.keyCode);\n        //     this.inputs.forEach((el, i) => i !== 0 && (el.innerText = ''));\n        //     this.inputs[0].innerText = char;\n        // }\n\n        // validate group\n        if (!hasSelection && innerText.length >= dataGroup.length) {\n            e.preventDefault();\n        }\n    }\n\n    private onKeyUp(e: React.KeyboardEvent<HTMLSpanElement>): void {\n        const { onChangeValueText, format, onSubmit, onToggle } = this.props;\n        const input = e.currentTarget;\n        const { innerText, nextSibling, previousSibling } = input;\n\n        if (e.keyCode === keys.ENTER) {\n            e.preventDefault();\n\n            if (this.focused) {\n                this.focused.blur();\n            }\n            onSubmit();\n            return;\n        }\n\n        if (e.keyCode === keys.ESC) {\n            onToggle();\n            return;\n        }\n\n        if (this.state.allSelected) {\n            if (e.keyCode === keys.BACKSPACE || e.keyCode === keys.DELETE) {\n                // delete all\n                this.inputs.forEach(el => (el.innerText = ''));\n\n                this.selectText(this.inputs[0]);\n            }\n\n            this.setState({ allSelected: false });\n        }\n\n        // remove text / focus prev\n        else if (e.keyCode === keys.BACKSPACE) {\n            if (innerText) {\n                input.innerText = '';\n            } else if (previousSibling instanceof HTMLSpanElement) {\n                this.selectText(previousSibling);\n            }\n        }\n\n        // focus next\n        else if (\n            (innerText.length >= getAttribute(input, 'data-group').length &&\n                !FORBIDDEN_KEYS.includes(e.keyCode)) ||\n            e.keyCode === keys.DOT ||\n            e.keyCode === keys.COMMA\n        ) {\n            if (!nextSibling) {\n                this.selectText(input);\n            } else if (nextSibling instanceof HTMLSpanElement) {\n                this.selectText(nextSibling);\n            }\n\n            onChangeValueText(joinDates(this.inputs, format));\n        }\n    }\n\n    private onClick(e: React.SyntheticEvent<HTMLSpanElement>): void {\n        this.selectText(e.currentTarget);\n    }\n\n    private onDblClick(e: React.SyntheticEvent<HTMLSpanElement>) {\n        const input = e.currentTarget;\n\n        if (input.parentNode && this.inputs.some(el => Boolean(el.innerText))) {\n            this.selectText(this.inputs[0]);\n            this.selectText(input.parentNode as HTMLElement);\n            this.setState({ allSelected: true });\n        }\n    }\n\n    private onFocus(e: React.SyntheticEvent<HTMLSpanElement>): void {\n        this.selectText(e.currentTarget);\n    }\n\n    private onBlur(e: React.SyntheticEvent<HTMLSpanElement>): void {\n        const input = e.target as HTMLSpanElement;\n        const value = input.innerText;\n        const dataGroup = getAttribute(input, 'data-group');\n        const formatType = getFormatType(dataGroup);\n\n        const fillZero = () => {\n            const innerText = `0${value}`;\n\n            input.innerText = innerText;\n        };\n\n        switch (formatType) {\n            case 'day':\n                if (value === '1' || value === '2' || value === '3') {\n                    fillZero();\n                }\n                break;\n            case 'month':\n                if (value === '1') {\n                    fillZero();\n                }\n                break;\n        }\n\n        // check if timebomb is still focused\n        setTimeout(() => {\n            const { focused } = this;\n\n            if (\n                this.props.open &&\n                focused &&\n                !getAttribute(focused, 'data-react-timebomb-selectable')\n            ) {\n                this.props.onToggle();\n            }\n        }, 0);\n    }\n\n    private onChange(e: React.KeyboardEvent<HTMLSpanElement>): void {\n        const { format, onChangeValueText } = this.props;\n        const input = e.currentTarget;\n        const { innerText, nextSibling } = input;\n\n        onChangeValueText(joinDates(this.inputs, format));\n\n        if (innerText.length >= getAttribute(input, 'data-group').length) {\n            if (nextSibling instanceof HTMLSpanElement) {\n                nextSibling.focus();\n            }\n        }\n    }\n\n    private onClear(e: React.MouseEvent<HTMLButtonElement>): void {\n        e.stopPropagation();\n\n        this.props.onClear();\n    }\n\n    private onToggle(e: React.SyntheticEvent<HTMLSpanElement>): void {\n        const { open, disabled, onToggle } = this.props;\n\n        if (disabled) {\n            return;\n        }\n\n        if (!this.inputs.some(inp => inp === e.target) || !open) {\n            onToggle();\n        }\n    }\n}\n"]}