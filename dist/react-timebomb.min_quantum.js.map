{"version":3,"sources":["src/value.tsx"],"names":["React","$fsx","r","styled_components_1","utils_1","Flex","default","div","Container","Input","span","Button","button","ClearButton","Placeholder","Icon","WHITELIST_KEYS","keys","BACKSPACE","DELETE","TAB","exports","Value","PureComponent","[object Object]","props","super","this","searchInputs","onSearchRef","bind","onKeyDown","onKeyUp","onFocus","onChange","onClear","onToggle","formatGroups","format","split","reduce","memo","char","prevChar","length","substr","focused","document","querySelector","prevProps","open","value","some","inp","parts","splitDate","input","forEach","i","innerText","focus","selectText","placeholder","showPlaceholder","createElement","data-role","className","onClick","renderValue","tabIndex","map","group","separator","contentEditable","data-placeholder","data-separator","key","data-group","ref","el","range","createRange","sel","getSelection","selectNodeContents","removeAllRanges","addRange","push","e","onChangeValueText","allowValidation","currentTarget","nextSibling","previousSibling","hasSelection","Boolean","focusOffset","baseOffset","numericValue","parseInt","keyCode","ENTER","ESC","preventDefault","ARROW_RIGHT","HTMLSpanElement","ARROW_LEFT","ARROW_UP","ARROW_DOWN","isArrowUp","isNaN","isFinite","formatGroup","getAttribute","formatType","getFormatType","direction","newDate","manipulateDate","isDisabled","dateParts","nextValue","valid","validateFormatGroup","formatNumber","joinDates","dataValue","dataGroup","stringFromCharCode","groupValue","includes","metaKey","ctrlKey","blur","onSubmit","forbiddenKeys","SHIFT","setAttribute","stopPropagation","target"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport styled from 'styled-components';\nimport {\n    keys,\n    formatNumber,\n    splitDate,\n    joinDates,\n    stringFromCharCode,\n    validateFormatGroup,\n    getAttribute,\n    getFormatType,\n    manipulateDate,\n    isDisabled\n} from './utils';\nimport { ReactTimebombProps } from './typings';\n\ninterface ValueProps {\n    open?: boolean;\n    value?: Date;\n    valueText?: string;\n    format: string;\n    placeholder: ReactTimebombProps['placeholder'];\n    minDate: ReactTimebombProps['minDate'];\n    maxDate: ReactTimebombProps['maxDate'];\n    allowValidation?: boolean;\n    onToggle(): void;\n    onChangeValueText(valueText: string): void;\n    onSubmit(onToggle: () => void): void;\n}\n\nconst Flex = styled.div`\n    display: flex;\n    align-items: center;\n`;\n\nconst Container = styled(Flex)`\n    justify-content: space-between;\n    align-items: center;\n    padding: 5px 10px;\n    border: 1px solid #ccc;\n    cursor: pointer;\n    width: 100%;\n    height: 100%;\n`;\n\nconst Input = styled.span`\n    padding: 2px 0 2px 0;\n    min-width: 1px;\n    cursor: text;\n\n    &:focus {\n        outline: none;\n    }\n\n    &:last-of-type {\n        padding: 2px 10px 2px 0;\n    }\n\n    &:not(:last-of-type):after {\n        content: attr(data-separator);\n        width: 4px;\n        display: inline-block;\n    }\n\n    &:empty:before {\n        content: attr(data-placeholder);\n        color: #aaa;\n    }\n\n    &:empty:not(:last-of-type):after {\n        color: #aaa;\n    }\n`;\n\nconst Button = styled.button`\n    font-size: 13px;\n    color: #ccc;\n    cursor: pointer;\n    border: none;\n    line-height: 1;\n\n    &:hover {\n        color: #333;\n    }\n\n    &:focus {\n        outline: none;\n    }\n`;\n\nconst ClearButton = styled(Button)`\n    font-size: 18px;\n`;\n\nconst Placeholder = styled.span`\n    color: #aaa;\n    user-select: none;\n`;\n\nconst Icon = styled.span`\n    margin-right: 5px;\n    user-select: none;\n\n    &:after {\n        content: 'ðŸ“…';\n    }\n`;\n\nconst WHITELIST_KEYS = [keys.BACKSPACE, keys.DELETE, keys.TAB];\n\nexport class Value extends React.PureComponent<ValueProps> {\n    private searchInputs: HTMLSpanElement[] = [];\n\n    private get formatGroups(): string[] {\n        return this.props.format.split('').reduce(\n            (memo, char) => {\n                const prevChar = memo[memo.length - 1];\n\n                if (prevChar && char === prevChar.substr(0, 1)) {\n                    memo[memo.length - 1] += char;\n                } else {\n                    memo = [...memo, char];\n                }\n\n                return memo;\n            },\n            [] as string[]\n        );\n    }\n\n    private get focused(): HTMLElement | null {\n        return document.querySelector(':focus');\n    }\n\n    constructor(props: ValueProps) {\n        super(props);\n\n        this.onSearchRef = this.onSearchRef.bind(this);\n        this.onKeyDown = this.onKeyDown.bind(this);\n        this.onKeyUp = this.onKeyUp.bind(this);\n        this.onFocus = this.onFocus.bind(this);\n        this.onChange = this.onChange.bind(this);\n        this.onClear = this.onClear.bind(this);\n        this.onToggle = this.onToggle.bind(this);\n    }\n\n    public componentDidUpdate(prevProps: ValueProps): void {\n        const { open, value, format } = this.props;\n        const hasFocus = this.searchInputs.some(inp => inp === this.focused);\n\n        if (!hasFocus) {\n            if (prevProps.value !== value && value) {\n                const parts = splitDate(value, format);\n                const input = this.searchInputs[0];\n\n                this.searchInputs.forEach(\n                    (input, i) => (input.innerText = parts[i])\n                );\n\n                if (input) {\n                    input.focus();\n                }\n            }\n\n            if ((open && !prevProps.open) || value !== prevProps.value) {\n                const input = this.searchInputs[0];\n\n                if (input) {\n                    if (input.innerText === '') {\n                        input.focus();\n                    } else {\n                        this.selectText(input);\n                    }\n                }\n            }\n        }\n\n        if (!open && value) {\n            const parts = splitDate(value, format);\n\n            this.searchInputs.forEach(\n                (input, i) => (input.innerText = parts[i])\n            );\n        }\n    }\n\n    public render(): React.ReactNode {\n        const { placeholder, value, open } = this.props;\n        const showPlaceholder = placeholder && !open;\n\n        return (\n            <Container\n                data-role=\"value\"\n                className=\"react-slct-value react-timebomb-value\"\n                onClick={this.onToggle}\n            >\n                <Flex>\n                    <Icon className=\"react-timebomb-icon\" />\n                    <Flex>\n                        {this.renderValue()}\n                        {showPlaceholder && (\n                            <Placeholder className=\"react-timebomb-placeholder\">\n                                {placeholder}\n                            </Placeholder>\n                        )}\n                    </Flex>\n                </Flex>\n                <Flex>\n                    {value && (\n                        <ClearButton\n                            className=\"react-timebomb-clearer\"\n                            tabIndex={-1}\n                            onClick={this.onClear}\n                        >\n                            Ã—\n                        </ClearButton>\n                    )}\n                    <Button tabIndex={-1} className=\"react-timebomb-arrow\">\n                        {open ? 'â–²' : 'â–¼'}\n                    </Button>\n                </Flex>\n            </Container>\n        );\n    }\n\n    private renderValue(): React.ReactNode {\n        const { open, value } = this.props;\n\n        if (!open && !value) {\n            return null;\n        }\n\n        const { formatGroups } = this;\n\n        return (\n            <Flex>\n                {formatGroups.map((group, i) => {\n                    if (group === '.' || group === ':' || group === ' ') {\n                        return null;\n                    } else {\n                        const separator = formatGroups[i + 1];\n\n                        return (\n                            <Input\n                                contentEditable\n                                data-placeholder={group}\n                                data-separator={separator}\n                                key={group}\n                                data-group={group}\n                                ref={this.onSearchRef as any}\n                                onKeyDown={this.onKeyDown}\n                                onKeyUp={this.onKeyUp}\n                                onFocus={this.onFocus}\n                                onClick={this.onFocus}\n                                onChange={this.onChange}\n                            />\n                        );\n                    }\n                })}\n            </Flex>\n        );\n    }\n\n    private selectText(el: HTMLElement | undefined) {\n        if (el) {\n            const range = document.createRange();\n            const sel = getSelection();\n\n            range.selectNodeContents(el);\n\n            sel.removeAllRanges();\n            sel.addRange(range);\n        }\n    }\n\n    private onSearchRef(el?: HTMLSpanElement): void {\n        if (el) {\n            this.searchInputs.push(el);\n        } else {\n            this.searchInputs = [];\n        }\n    }\n\n    private onKeyDown(e: React.KeyboardEvent<HTMLSpanElement>): void {\n        const {\n            onChangeValueText,\n            format,\n            value,\n            allowValidation\n        } = this.props;\n        const input = e.currentTarget;\n        const { innerText, nextSibling, previousSibling } = input;\n        const sel = getSelection();\n        const hasSelection = Boolean(sel.focusOffset - sel.baseOffset);\n        let numericValue = parseInt(innerText, 10);\n\n        switch (e.keyCode) {\n            case keys.ENTER:\n            case keys.ESC:\n                e.preventDefault();\n                return;\n            case keys.ARROW_RIGHT:\n                e.preventDefault();\n\n                if (nextSibling instanceof HTMLSpanElement) {\n                    nextSibling.focus();\n                } else {\n                    this.selectText(input);\n                }\n                return;\n            case keys.ARROW_LEFT:\n                e.preventDefault();\n\n                if (previousSibling instanceof HTMLSpanElement) {\n                    previousSibling.focus();\n                } else {\n                    this.selectText(input);\n                }\n                return;\n            case keys.ARROW_UP:\n            case keys.ARROW_DOWN:\n                e.preventDefault();\n\n                const isArrowUp = e.keyCode === keys.ARROW_UP;\n\n                if (isNaN(numericValue)) {\n                    numericValue = 0;\n                }\n\n                if (isFinite(numericValue)) {\n                    const formatGroup = getAttribute(input, 'data-group');\n                    const formatType = getFormatType(formatGroup);\n\n                    if (!allowValidation) {\n                        const nextValue = numericValue + (isArrowUp ? 1 : -1);\n                        const valid = validateFormatGroup(\n                            nextValue,\n                            formatGroup\n                        );\n\n                        if (valid) {\n                            input.innerText =\n                                typeof valid === 'string'\n                                    ? valid\n                                    : formatNumber(nextValue);\n                        }\n                    } else {\n                        if (value && formatType) {\n                            const direction = isArrowUp ? 'add' : 'subtract';\n\n                            const newDate = manipulateDate(\n                                value,\n                                formatType,\n                                direction\n                            );\n                            const disabled = isDisabled(newDate, this.props);\n\n                            if (!disabled) {\n                                const dateParts = splitDate(newDate, format);\n\n                                this.searchInputs.map(\n                                    (inp, i) => (inp.innerText = dateParts[i])\n                                );\n                            }\n                        }\n                    }\n\n                    this.selectText(input);\n                    onChangeValueText(joinDates(this.searchInputs, format));\n                }\n                return;\n        }\n\n        const dataValue = getAttribute(input, 'data-value');\n        const dataGroup = getAttribute(input, 'data-group')!;\n        const char = stringFromCharCode(e.keyCode);\n        const groupValue = dataValue && !hasSelection ? dataValue + char : char;\n\n        if (WHITELIST_KEYS.includes(e.keyCode) || e.metaKey || e.ctrlKey) {\n            return;\n        }\n\n        const valid = validateFormatGroup(groupValue, dataGroup);\n\n        if (!valid) {\n            e.preventDefault();\n        } else if (typeof valid === 'string') {\n            e.preventDefault();\n\n            input.innerText = valid;\n        }\n\n        if (hasSelection) {\n            return;\n        }\n\n        // validate group\n        if (innerText.length >= dataGroup.length) {\n            e.preventDefault();\n        }\n    }\n\n    private onKeyUp(e: React.KeyboardEvent<HTMLSpanElement>): void {\n        const { onChangeValueText, format, allowValidation } = this.props;\n        const input = e.currentTarget;\n        const { innerText, nextSibling } = input;\n\n        if (e.keyCode === keys.ENTER || e.keyCode === keys.ESC) {\n            if (this.focused) {\n                this.focused.blur();\n            }\n            this.props.onSubmit(this.props.onToggle);\n\n            return;\n        }\n\n        const forbiddenKeys = [\n            keys.SHIFT,\n            keys.ARROW_LEFT,\n            keys.ARROW_RIGHT,\n            keys.ARROW_UP,\n            keys.ARROW_DOWN,\n            keys.TAB\n        ];\n\n        // focus next\n        if (\n            innerText.length >= getAttribute(input, 'data-group').length &&\n            !forbiddenKeys.includes(e.keyCode)\n        ) {\n            if (allowValidation || !nextSibling) {\n                this.selectText(input);\n            } else if (nextSibling instanceof HTMLSpanElement) {\n                this.selectText(nextSibling);\n            }\n\n            onChangeValueText(joinDates(this.searchInputs, format));\n        }\n\n        input.setAttribute('data-value', innerText);\n    }\n\n    private onFocus(e: React.SyntheticEvent<HTMLSpanElement>): void {\n        this.selectText(e.currentTarget);\n    }\n\n    private onChange(e: React.KeyboardEvent<HTMLSpanElement>): void {\n        const { format, onChangeValueText } = this.props;\n        const input = e.currentTarget;\n        const { innerText, nextSibling } = input;\n\n        onChangeValueText(joinDates(this.searchInputs, format));\n\n        if (innerText.length >= getAttribute(input, 'data-group').length) {\n            if (nextSibling instanceof HTMLSpanElement) {\n                nextSibling.focus();\n            }\n        }\n    }\n\n    private onClear(e: React.SyntheticEvent<HTMLButtonElement>): void {\n        e.stopPropagation();\n\n        this.props.onChangeValueText('');\n    }\n\n    private onToggle(e: React.SyntheticEvent<HTMLSpanElement>): void {\n        const { open, onToggle } = this.props;\n\n        if (\n            this.searchInputs.some(inp => inp === e.target) === false ||\n            !open\n        ) {\n            onToggle();\n        }\n    }\n}\n"]}