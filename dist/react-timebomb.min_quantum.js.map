{"version":3,"sources":["src/components/button.tsx","src/value/value.tsx"],"names":["React","$fsx","r","styled_components_1","StyledButton","default","button","props","selected","mobile","css","exports","Button","createElement","Object","assign","data-react-timebomb-selectable","data-role","type","SmallButton","ArrowButton","className","disabled","tabIndex","open","utils_1","button_1","Flex","div","Container","Input","span","ClearButton","ClearButtonX","Placeholder","Icon","icon","META_KEYS","keys","BACKSPACE","DELETE","TAB","FORBIDDEN_KEYS","SHIFT","ARROW_LEFT","ARROW_RIGHT","ARROW_UP","ARROW_DOWN","Value","PureComponent","[object Object]","super","this","inputs","onFocus","timeout","e","clearTimeout","input","currentTarget","selectElement","setTimeout","state","allSelected","formatGroup","getAttribute","onChangeFormatGroup","onSearchRef","bind","onKeyDown","onKeyUp","onClick","onDblClick","onBlur","onChange","onClear","onToggle","formatGroups","format","split","reduce","memo","char","prevChar","length","substr","formatSplitExpr","test","focused","document","querySelector","iconClass","showTime","showDate","prevProps","value","mode","allowValidation","hasFocus","some","inp","allowTextSelection","parts","splitDate","forEach","i","innerText","focus","find","el","getFormatType","setState","forceUpdate","placeholder","ArrowButtonComp","arrowButtonComponent","showPlaceholder","showClearer","timeOnly","renderValue","contentEditable","map","group","g","separator","data-placeholder","data-separator","replaceSpaceWithNbsp","key","data-group","ref","onDoubleClick","push","onChangeValueText","timeStep","nextSibling","previousSibling","numericFormat","formatIsActualNumber","sel","getSelection","hasSelection","Boolean","focusOffset","baseOffset","numericValue","parseInt","keyCode","ENTER","ESC","DOT","COMMA","preventDefault","HTMLSpanElement","isArrowUp","isNaN","isFinite","formatType","direction","newDate","manipulateDate","isEnabled","dateParts","add","nextValue","valid","validateFormatGroup","formatNumber","joinDates","stringFromCharCode","groupValue","includes","metaKey","ctrlKey","firstInput","validatedChar","clearSelection","onSubmit","blur","parentNode","onAllSelect","target","dataGroup","filledValue","fillZero","stopPropagation"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4+WACA,MAAAA,EAAAC,EAAAC,EAAA,SACAC,EAAAF,EAAAC,EAAA,qBAOME,EAAeD,EAAAE,QAAOC;;;;;;;kBAOVC,GAAyBA,EAAMC,SAAW,OAAS;;MAE/DD,GACEA,EAAME,OACAN,EAAAO;;;;;;gBAOA;;;;;;;;;;;;;;;4BAecH,GAChBA,EAAMC,SAAW,OAAS;;;;;;EAQzBG,EAAAC,OAASL,CAAAA,GAClBP,EAAAa,cAACT,EAAYU,OAAAC,OAAA,CAAAC,kCAAA,EAAAC,YAEC,SACVC,KAAK,UACDX,KAICI,EAAAQ,YAAchB,EAAAE,QAAOM,EAAAC;;;;;;;;;;;;;;EAqBrBD,EAAAS,YAAcb,CAAAA,GACvBP,EAAAa,cAACF,EAAAQ,YAAW,CACRE,UAAU,uBACVC,SAAUf,EAAMe,SAChBC,UAAW,GAEVhB,EAAMiB,KAAO,IAAM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ohDCvF5B,MAAAxB,EAAAC,EAAAC,EAAA,SACAC,EAAAF,EAAAC,EAAA,qBACAuB,EAAAxB,EAAAC,EAAA,GAmBAwB,EAAAzB,EAAAC,EAAA,GAiCaS,EAAAgB,KAAOxB,EAAAE,QAAOuB;;;;;;EAQdjB,EAAAkB,UAAY1B,EAAAE,QAAOM,EAAAgB;;;;;cAKlBpB,GACNA,EAAMe,SAAW,cAAgB;;;;EAMzC,MAAMQ,EAAQ3B,EAAAE,QAAO0B;;;cAGPxB,GAAwBA,EAAMe,SAAW,cAAgB;sBACjDf,GACdA,EAAMe,SAAW,OAAS;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA8BrBX,EAAAqB,YAAc7B,EAAAE,QAAOqB,EAAAP;;EAIlC,MAAMc,EAAe9B,EAAAE,QAAO0B;;;;EAMfpB,EAAAuB,YAAc/B,EAAAE,QAAO0B;;;EAKrBpB,EAAAwB,KAAOhC,EAAAE,QAAO0B;;;;;oBAKPxB,GAA6BA,EAAM6B;;EAIvD,MAAMC,EAAY,CAACZ,EAAAa,KAAKC,UAAWd,EAAAa,KAAKE,OAAQf,EAAAa,KAAKG,KAE/CC,EAAiB,CACnBjB,EAAAa,KAAKK,MACLlB,EAAAa,KAAKM,WACLnB,EAAAa,KAAKO,YACLpB,EAAAa,KAAKQ,SACLrB,EAAAa,KAAKS,WACLtB,EAAAa,KAAKG,KAGT9B,EAAAqC,MAAA,cAA2BhD,EAAMiD,cA+C7BC,YAAY3C,GACR4C,MAAM5C,GA/CF6C,KAAAC,OAA4B,GA0d5BD,KAAAE,QAAU,MACd,IAAIC,EAEJ,OAAOC,IACHC,aAAaF,GAEb,MAAMG,EAAQF,EAAEG,cAEhBlC,EAAAmC,cAAcF,GAEdH,EAAUM,WAAW,KACjB,IAAKT,KAAKU,MAAMC,YAAa,CACzB,MAAMC,EAAcvC,EAAAwC,aAAaP,EAAO,cAExCN,KAAK7C,MAAM2D,oBAAoBF,KAEpC,MAhBO,GAzadZ,KAAKU,MAAQ,GAEbV,KAAKe,YAAcf,KAAKe,YAAYC,KAAKhB,MACzCA,KAAKiB,UAAYjB,KAAKiB,UAAUD,KAAKhB,MACrCA,KAAKkB,QAAUlB,KAAKkB,QAAQF,KAAKhB,MACjCA,KAAKE,QAAUF,KAAKE,QAAQc,KAAKhB,MACjCA,KAAKmB,QAAUnB,KAAKmB,QAAQH,KAAKhB,MACjCA,KAAKoB,WAAapB,KAAKoB,WAAWJ,KAAKhB,MACvCA,KAAKqB,OAASrB,KAAKqB,OAAOL,KAAKhB,MAC/BA,KAAKsB,SAAWtB,KAAKsB,SAASN,KAAKhB,MACnCA,KAAKuB,QAAUvB,KAAKuB,QAAQP,KAAKhB,MACjCA,KAAKwB,SAAWxB,KAAKwB,SAASR,KAAKhB,MA1DvCyB,mBACI,OAAOzB,KAAK7C,MAAMuE,OAAOC,MAAM,IAAIC,OAC/B,CAACC,EAAMC,KACH,MAAMC,EAAWF,EAAKA,EAAKG,OAAS,GAYpC,OATID,GAAaD,IAASC,EAASE,OAAO,EAAG,IACxC5D,EAAA6D,gBAAgBC,KAAKJ,IAClB1D,EAAA6D,gBAAgBC,KAAKL,GAEzBD,EAAKA,EAAKG,OAAS,IAAMF,EAEzBD,EAAO,IAAIA,EAAMC,GAGdD,GAEX,IAIRO,cACI,OAAOC,SAASC,cAAc,UAGlCC,gBACI,MAAMC,SAAEA,EAAAC,SAAUA,GAAazC,KAAK7C,MAEpC,OAAKsF,GAAYD,EACN,OAGJ,WAGXxD,WACI,OAAQgB,KAAKuC,WACT,IAAK,WACD,MAAO,KACX,IAAK,OACD,MAAO,KAqBZzC,mBAAmB4C,GACtBjC,WAAW,KACP,MAAMrC,KAAEA,EAAAuE,MAAMA,EAAAjB,OAAOA,EAAAkB,KAAQA,EAAAC,gBAAMA,GAAoB7C,KAAK7C,MACtD2F,EAAW9C,KAAKC,OAAO8C,KAAKC,GAAOA,IAAQhD,KAAKoC,SAChDa,EACO,QAATL,GAA2B,UAATA,GAA6B,SAATA,EAE1C,IAAKE,GACG1E,EAAM,CACN,GAAIsE,EAAUC,QAAUA,GAAAA,EAAgB,CACpC,MAAMO,EAAQ7E,EAAA8E,UAAUR,EAAOjB,GACzBpB,EAAQN,KAAKC,OAAO,GAE1BD,KAAKC,OAAOmD,QACR,CAAC9C,EAAO+C,IAAO/C,EAAMgD,UAAYJ,EAAMG,IAGvC/C,GAAS2C,GACT3C,EAAMiD,QAId,GAAIN,KACKP,EAAUtE,MAAQuE,IAAUD,EAAUC,OAAO,CAC9C,MAAOrC,GAASN,KAAKC,OAEjBK,GACAjC,EAAAmC,cAAcF,IAOlC,GACIlC,GACAsE,EAAUE,OAASA,IAClB5C,KAAKU,MAAMC,aACZsC,EACF,CACE,MAAM3C,EAAQN,KAAKC,OAAOuD,KAAKC,IAC3B,MAAM/B,EAASrD,EAAAwC,aAAa4C,EAAI,cAGhC,OAFapF,EAAAqF,cAAchC,KAEXkB,IAGpBvE,EAAAmC,cAAcF,GAGlB,IAAKlC,GAAQuE,EAAO,CAChB,MAAMO,EAAQ7E,EAAA8E,UAAUR,EAAOjB,GAE/B1B,KAAKC,OAAOmD,QAAQ,CAAC9C,EAAO+C,IAAO/C,EAAMgD,UAAYJ,EAAMG,IAG3DjF,GAAQsE,EAAUC,QAAUA,IAAUE,GACtC7C,KAAKC,OAAOmD,QAAQ9C,GAAUA,EAAMgD,UAAY,IAG/ClF,GACD4B,KAAK2D,SAAS,CAAEhD,aAAa,KAElC,IAGAb,oBACCE,KAAK7C,MAAMwF,OACX3C,KAAK4D,cAIN9D,SACH,MAAM+D,YACFA,EAAAlB,MACAA,EAAAF,SACAA,EAAAD,SACAA,EAAAtE,SACAA,EAAAE,KACAA,GACA4B,KAAK7C,MACH2G,EAAkB9D,KAAK7C,MAAM4G,sBAAwBzF,EAAAN,YACrDgG,EAAkBH,IAAgBzF,EAClC6F,EAActB,IAAUzE,EACxBgG,EAAW1B,IAAaC,EAE9B,OACI7F,EAAAa,cAACF,EAAAkB,UAAS,CAAAZ,YACI,QACVI,UAAU,wCACVC,SAAUA,EACViD,QAASnB,KAAKwB,UAEd5E,EAAAa,cAACF,EAAAgB,KAAI,KACD3B,EAAAa,cAACF,EAAAwB,KAAI,CACDC,KAAMgB,KAAKhB,KACXf,iCAAkC+B,KAAKuC,cAE3C3F,EAAAa,cAACF,EAAAgB,KAAI,KACAyB,KAAKmE,cACLH,GACGpH,EAAAa,cAACF,EAAAuB,YAAW,CAACb,UAAU,8BAClB4F,KAKjBjH,EAAAa,cAACF,EAAAgB,KAAI,KACA0F,GACGrH,EAAAa,cAACF,EAAAqB,YAAW,CACRX,UAAU,yBACVE,UAAW,EACXgD,QAASnB,KAAKuB,SAEd3E,EAAAa,cAACoB,EAAY,KAAA,OAGnBqF,GACEtH,EAAAa,cAACqG,EAAe,CAAC5F,SAAUA,EAAUE,KAAMA,MAOvD0B,cACJ,MAAM1B,KAAEA,EAAAF,SAAMA,EAAAb,OAAUA,EAAAsF,MAAQA,GAAU3C,KAAK7C,MACzCiH,GAAmBlG,IAAab,EAEtC,IAAKe,IAASuE,EACV,OAAO,KAGX,MAAMlB,EAAezB,KAAKyB,aAE1B,OACI7E,EAAAa,cAACF,EAAAgB,KAAI,KACAkD,EAAa4C,IAAI,CAACC,EAAOjB,KACtB,GAAIiB,EAAM3C,MAAM,IAAIoB,KAAKwB,GAAKlG,EAAA6D,gBAAgBC,KAAKoC,IAC/C,OAAO,KACJ,CACH,MAAMC,EAAY/C,EAAa4B,EAAI,GAEnC,OACIzG,EAAAa,cAACiB,EAAK,CAAAd,kCAAA,EAEFwG,gBAAiBA,EACjBlG,SAAUA,EAAQuG,mBACAH,EAAKI,iBACPrG,EAAAsG,qBAAqBH,GACrCI,IAAKN,EAAKO,aACEP,EACZQ,IAAK9E,KAAKe,YACVE,UAAWjB,KAAKiB,UAChBC,QAASlB,KAAKkB,QACdhB,QAASF,KAAKE,QACdmB,OAAQrB,KAAKqB,OACbF,QAASnB,KAAKmB,QACd4D,cAAe/E,KAAKoB,WACpBE,SAAUtB,KAAKsB,eASnCxB,YAAY2D,GACZA,EACAzD,KAAKC,OAAO+E,KAAKvB,GAEjBzD,KAAKC,OAAS,GAIdH,UAAUM,GACd,MAAM6E,kBACFA,EAAAvD,OACAA,EAAAiB,MACAA,EAAAE,gBACAA,EAAAqC,SACAA,GACAlF,KAAK7C,MACHmD,EAAQF,EAAEG,eACV+C,UAAEA,EAAA6B,YAAWA,EAAAC,gBAAaA,GAAoB9E,EAC9CM,EAAcvC,EAAAwC,aAAaP,EAAO,cAClC+E,EAAgBhH,EAAAiH,qBAAqB1E,GACrC2E,EAAMC,eACNC,EAAeC,QAAQH,EAAII,YAAcJ,EAAIK,YACnD,IAAIC,EAAeC,SAASxC,EAAW,IAEvC,OAAQlD,EAAE2F,SACN,KAAK1H,EAAAa,KAAK8G,MACV,KAAK3H,EAAAa,KAAK+G,IACV,KAAK5H,EAAAa,KAAKC,UACV,KAAKd,EAAAa,KAAKgH,IACV,KAAK7H,EAAAa,KAAKiH,MAEN,YADA/F,EAAEgG,iBAEN,KAAK/H,EAAAa,KAAKO,YAQN,OAPAW,EAAEgG,sBAEEjB,aAAuBkB,gBACvBlB,EAAY5B,QAEZlF,EAAAmC,cAAcF,IAGtB,KAAKjC,EAAAa,KAAKM,WAQN,OAPAY,EAAEgG,sBAEEhB,aAA2BiB,gBAC3BjB,EAAgB7B,QAEhBlF,EAAAmC,cAAcF,IAGtB,KAAKjC,EAAAa,KAAKQ,SACV,KAAKrB,EAAAa,KAAKS,WAGN,GAFAS,EAAEgG,kBAEGf,EACD,OAGJ,MAAMiB,EAAYlG,EAAE2F,UAAY1H,EAAAa,KAAKQ,SAMrC,GAJI6G,MAAMV,KACNA,EAAe,GAGfW,SAASX,GAAe,CACxB,MAAMY,EAAapI,EAAAqF,cAAc9C,GAEjC,GAAKiC,GAgBD,GAAIF,GAAS8D,EAAY,CACrB,MAAMC,EAAYJ,EAAY,MAAQ,WAEhCK,EAAUtI,EAAAuI,eACZjE,EACA8D,EACAC,EACAxB,GAQJ,GANgB7G,EAAAwI,UACZ,MACAF,EACA3G,KAAK7C,OAGI,CACT,MAAM2J,EAAYzI,EAAA8E,UAAUwD,EAASjF,GAErC1B,KAAKC,OAAOoE,IACR,CAACrB,EAAKK,IAAOL,EAAIM,UAAYwD,EAAUzD,UAnCjC,CAClB,MAAM0D,EAAqB,WAAfN,GAA0BvB,GAAgB,EAChD8B,EACFnB,GAAgBS,EAAYS,GAAOA,GACjCE,EAAQ5I,EAAA6I,oBACVF,EACApG,GAGAqG,IACA3G,EAAMgD,UACe,iBAAV2D,EACDA,EACA5I,EAAA8I,aAAaH,IA4B/B3I,EAAAmC,cAAcF,GACd2E,EAAkB5G,EAAA+I,UAAUpH,KAAKC,OAAQyB,IAE7C,OAGR,MAAMI,EAAOzD,EAAAgJ,mBAAmBjH,EAAE2F,SAC5BuB,EAAahE,IAAcmC,EAAenC,EAAYxB,EAAOA,EAEnE,GAAI7C,EAAUsI,SAASnH,EAAE2F,UAAY3F,EAAEoH,SAAWpH,EAAEqH,QAChD,OAGJ,IAAKpC,EAED,YADAjF,EAAEgG,iBAIN,MAAMa,EAAQ5I,EAAA6I,oBAAoBI,EAAY1G,GAU9C,GARKqG,EAEuB,iBAAVA,IACd7G,EAAEgG,iBAEF9F,EAAMgD,UAAY2D,GAJlB7G,EAAEgG,iBAQFpG,KAAKU,MAAMC,aACXP,EAAE2F,UAAY1H,EAAAa,KAAKC,WACnBiB,EAAE2F,UAAY1H,EAAAa,KAAKE,OACrB,CACE,MAAOsI,GAAc1H,KAAKC,OAC1B,IAAI0H,EAAgBtJ,EAAA6I,oBAAoBpF,EAAMlB,GAE1C+G,IAAmC,IAAlBA,IACjBA,EAAgB7F,GAGhB6F,IACAvH,EAAEgG,iBAEFpG,KAAKC,OAAOmD,QAAQ,CAACK,EAAIJ,IAAY,IAANA,IAAYI,EAAGH,UAAY,KAE7B,IAAzBqE,EAAc3F,OACd3D,EAAAmC,cAAckH,IAEdrJ,EAAAuJ,iBAEAF,EAAWpE,UAAYqE,EACvBD,EAAWnE,QAEXlF,EAAAmC,cAAckH,EAAY,CAAC,SAMlCjC,GAAgBnC,EAAUtB,QAAUpB,EAAYoB,QACjD5B,EAAEgG,iBAIFtG,QAAQM,GACZ,MAAM6E,kBAAEA,EAAAvD,OAAmBA,EAAAmG,SAAQA,EAAArG,SAAUA,GAAaxB,KAAK7C,MACzDmD,EAAQF,EAAEG,eACV+C,UAAEA,EAAA6B,YAAWA,EAAAC,gBAAaA,GAAoB9E,EAEpD,GAAIF,EAAE2F,UAAY1H,EAAAa,KAAK8G,MAOnB,OANA5F,EAAEgG,iBAEEpG,KAAKoC,SACLpC,KAAKoC,QAAQ0F,YAEjBD,IAIAzH,EAAE2F,UAAY1H,EAAAa,KAAK+G,IAKnBjG,KAAKU,MAAMC,aACPP,EAAE2F,UAAY1H,EAAAa,KAAKC,WAAaiB,EAAE2F,UAAY1H,EAAAa,KAAKE,SAEnDY,KAAKC,OAAOmD,QAAQK,GAAOA,EAAGH,UAAY,IAE1CjF,EAAAmC,cAAcR,KAAKC,OAAO,KAG9BD,KAAK2D,SAAS,CAAEhD,aAAa,KAIxBP,EAAE2F,UAAY1H,EAAAa,KAAKC,UACpBmE,EACAhD,EAAMgD,UAAY,GACX8B,aAA2BiB,iBAClChI,EAAAmC,cAAc4E,IAMlB9B,EAAWtB,QAAU3D,EAAAwC,aAAaP,EAAO,cAAc0B,SAClD1C,EAAeiI,SAASnH,EAAE2F,UAC/B3F,EAAE2F,UAAY1H,EAAAa,KAAKgH,KACnB9F,EAAE2F,UAAY1H,EAAAa,KAAKiH,SAEdhB,EAEMA,aAAuBkB,iBAC9BhI,EAAAmC,cAAc2E,GAFd9G,EAAAmC,cAAcF,GAKlB2E,EAAkB5G,EAAA+I,UAAUpH,KAAKC,OAAQyB,KArCzCF,IAyCA1B,QAAQM,GACZ/B,EAAAmC,cAAcJ,EAAEG,eAGZT,WAAWM,GACf,MAAME,EAAQF,EAAEG,cAEZD,EAAMyH,YAAc/H,KAAKC,OAAO8C,KAAKU,GAAMiC,QAAQjC,EAAGH,cACtDjF,EAAAmC,cAAcR,KAAKC,OAAO,IAC1B5B,EAAAmC,cAAcF,EAAMyH,YACpB/H,KAAK2D,SAAS,CAAEhD,aAAa,GAAQX,KAAK7C,MAAM6K,cAwBhDlI,OAAOM,GACX,IAAKJ,KAAKU,MAAMC,YAAa,CACzB,MAAML,EAAQF,EAAE6H,OACVtF,EAAQrC,EAAMgD,UACd4E,EAAY7J,EAAAwC,aAAaP,EAAO,cAChCmG,EAAapI,EAAAqF,cAAcwE,GAEjC,GAAIzB,EAAY,CACZ,MAAM0B,EAAc9J,EAAA+J,SAASzF,EAAO8D,GAEhC0B,IACA7H,EAAMgD,UAAY6E,IAM9B1H,WAAW,KACP,MAAM2B,QAAEA,GAAYpC,KAGhBA,KAAK7C,MAAMiB,MACXgE,IACC/D,EAAAwC,aAAauB,EAAS,mCAEvBpC,KAAK7C,MAAMqE,YAEhB,GAGC1B,SAASM,GACb,MAAMsB,OAAEA,EAAAuD,kBAAQA,GAAsBjF,KAAK7C,MACrCmD,EAAQF,EAAEG,eACV+C,UAAEA,EAAA6B,YAAWA,GAAgB7E,EAEnC2E,EAAkB5G,EAAA+I,UAAUpH,KAAKC,OAAQyB,IAErC4B,EAAUtB,QAAU3D,EAAAwC,aAAaP,EAAO,cAAc0B,QAClDmD,aAAuBkB,iBACvBlB,EAAY5B,QAKhBzD,QAAQM,GACZA,EAAEiI,kBAEFrI,KAAK7C,MAAMoE,UAGPzB,SAASM,GACb,MAAMhC,KAAEA,EAAAF,SAAMA,EAAAsD,SAAUA,GAAaxB,KAAK7C,MAEtCe,GAIC8B,KAAKC,OAAO8C,KAAKC,GAAOA,IAAQ5C,EAAE6H,SAAY7J,GAC/CoD","sourcesContent":["// @ts-ignore\nimport * as React from 'react';\nimport styled, { css } from 'styled-components';\n\nexport interface ButtonProps {\n    selected?: boolean;\n    mobile?: boolean;\n}\n\nconst StyledButton = styled.button`\n    margin-right: 5px;\n    border: 1px solid #ccc;\n    border-radius: 3px;\n    padding: 3px 6px;\n    height: 21px;\n    box-sizing: border-box;\n    background: ${(props: ButtonProps) => (props.selected ? '#ccc' : '#fff')};\n\n    ${(props: ButtonProps) =>\n        props.mobile\n            ? css`\n                  font-size: 16px;\n                  margin-right: 6px;\n                  padding: 6px 12px;\n                  height: auto;\n                  min-height: 21px;\n              `\n            : ''}\n\n    &:focus {\n        outline: none;\n    }\n\n    &:disabled {\n        cursor: not-allowed;\n    }\n\n    &:not(:disabled) {\n        cursor: pointer;\n    }\n\n    &:not(:disabled):hover {\n        background-color: ${(props: ButtonProps) =>\n            props.selected ? '#ccc' : '#efefef'};\n    }\n\n    &:last-child {\n        margin-right: 0;\n    }\n`;\n\nexport const Button = (props: ButtonProps & React.ButtonHTMLAttributes<{}>) => (\n    <StyledButton\n        data-react-timebomb-selectable\n        data-role=\"button\"\n        type=\"button\"\n        {...props}\n    />\n);\n\nexport const SmallButton = styled(Button)`\n    font-size: 13px;\n    color: #ccc;\n    cursor: pointer;\n    border: none;\n    line-height: 1;\n\n    &:hover:not(:disabled) {\n        color: #333;\n    }\n\n    &:focus {\n        outline: none;\n    }\n`;\n\nexport interface ArrowButtonProps {\n    open?: boolean;\n    disabled?: boolean;\n}\n\nexport const ArrowButton = (props: ArrowButtonProps) => (\n    <SmallButton\n        className=\"react-timebomb-arrow\"\n        disabled={props.disabled}\n        tabIndex={-1}\n    >\n        {props.open ? '▲' : '▼'}\n    </SmallButton>\n);\n","import * as React from 'react';\nimport styled from 'styled-components';\nimport {\n    keys,\n    formatNumber,\n    splitDate,\n    joinDates,\n    stringFromCharCode,\n    validateFormatGroup,\n    getAttribute,\n    getFormatType,\n    manipulateDate,\n    isEnabled,\n    selectElement,\n    fillZero,\n    clearSelection,\n    formatSplitExpr,\n    formatIsActualNumber,\n    replaceSpaceWithNbsp\n} from '../utils';\nimport { ReactTimebombProps, ReactTimebombState } from '../typings';\nimport { ArrowButton, SmallButton } from '../components/button';\n\nexport interface ValueProps {\n    open?: boolean;\n    value?: Date;\n    format: string;\n    placeholder: ReactTimebombProps['placeholder'];\n    minDate: ReactTimebombProps['minDate'];\n    maxDate: ReactTimebombProps['maxDate'];\n    showDate: ReactTimebombState['showDate'];\n    showTime: ReactTimebombState['showTime'];\n    mode: ReactTimebombState['mode'];\n    allowValidation: ReactTimebombState['allowValidation'];\n    arrowButtonComponent: ReactTimebombProps['arrowButtonComponent'];\n    disabled: ReactTimebombProps['disabled'];\n    mobile: ReactTimebombProps['mobile'];\n    timeStep: ReactTimebombProps['timeStep'];\n    onToggle(): void;\n    onChangeValueText(valueText?: string, commit?: boolean): void;\n    onChangeFormatGroup(formatGroup: string): void;\n    onAllSelect(): void;\n    onSubmit(): void;\n    onClear(): void;\n}\n\ninterface ValueState {\n    allSelected?: boolean;\n}\n\ninterface InputProps {\n    disabled?: boolean;\n}\n\nexport const Flex = styled.div`\n    display: flex;\n    align-items: center;\n    white-space: nowrap;\n    position: relative;\n    line-height: 1;\n`;\n\nexport const Container = styled(Flex)`\n    justify-content: space-between;\n    align-items: center;\n    padding: 5px 10px;\n    border: 1px solid #ccc;\n    cursor: ${(props: { disabled?: boolean }) =>\n        props.disabled ? 'not-allowed' : 'pointer'};\n    width: 100%;\n    height: 100%;\n    box-sizing: border-box;\n`;\n\nconst Input = styled.span`\n    padding: 2px 0 2px 0;\n    min-width: 1px;\n    cursor: ${(props: InputProps) => (props.disabled ? 'not-allowed' : 'text')};\n    pointer-events: ${(props: InputProps) =>\n        props.disabled ? 'none' : 'auto'};\n\n    &:focus {\n        outline: none;\n    }\n\n    &:last-of-type {\n        padding: 2px 10px 2px 0;\n    }\n\n    &:not(:last-of-type):after {\n        content: attr(data-separator);\n        min-width: 4px;\n        display: inline-block;\n    }\n\n    &:empty:before {\n        content: attr(data-placeholder);\n        color: #aaa;\n    }\n\n    &:empty:not(:last-of-type):after {\n        color: #aaa;\n    }\n\n    &:not([contenteditable='true']) {\n        user-select: none;\n    }\n`;\n\nexport const ClearButton = styled(SmallButton)`\n    font-size: 18px;\n`;\n\nconst ClearButtonX = styled.span`\n    position: relative;\n    left: -1px;\n    top: -2px;\n`;\n\nexport const Placeholder = styled.span`\n    color: #aaa;\n    user-select: none;\n`;\n\nexport const Icon = styled.span`\n    margin-right: 5px;\n    user-select: none;\n\n    &:after {\n        content: '${(props: { icon: string }) => props.icon}';\n    }\n`;\n\nconst META_KEYS = [keys.BACKSPACE, keys.DELETE, keys.TAB];\n\nconst FORBIDDEN_KEYS = [\n    keys.SHIFT,\n    keys.ARROW_LEFT,\n    keys.ARROW_RIGHT,\n    keys.ARROW_UP,\n    keys.ARROW_DOWN,\n    keys.TAB\n];\n\nexport class Value extends React.PureComponent<ValueProps, ValueState> {\n    private inputs: HTMLSpanElement[] = [];\n\n    private get formatGroups(): string[] {\n        return this.props.format.split('').reduce(\n            (memo, char) => {\n                const prevChar = memo[memo.length - 1];\n\n                if (\n                    (prevChar && char === prevChar.substr(0, 1)) ||\n                    (formatSplitExpr.test(prevChar) &&\n                        formatSplitExpr.test(char))\n                ) {\n                    memo[memo.length - 1] += char;\n                } else {\n                    memo = [...memo, char];\n                }\n\n                return memo;\n            },\n            [] as string[]\n        );\n    }\n\n    private get focused(): HTMLElement | null {\n        return document.querySelector(':focus');\n    }\n\n    private get iconClass(): 'time' | 'calendar' {\n        const { showTime, showDate } = this.props;\n\n        if (!showDate && showTime) {\n            return 'time';\n        }\n\n        return 'calendar';\n    }\n\n    private get icon() {\n        switch (this.iconClass) {\n            case 'calendar':\n                return '📅';\n            case 'time':\n                return '⏱';\n        }\n    }\n\n    constructor(props: ValueProps) {\n        super(props);\n\n        this.state = {};\n\n        this.onSearchRef = this.onSearchRef.bind(this);\n        this.onKeyDown = this.onKeyDown.bind(this);\n        this.onKeyUp = this.onKeyUp.bind(this);\n        this.onFocus = this.onFocus.bind(this);\n        this.onClick = this.onClick.bind(this);\n        this.onDblClick = this.onDblClick.bind(this);\n        this.onBlur = this.onBlur.bind(this);\n        this.onChange = this.onChange.bind(this);\n        this.onClear = this.onClear.bind(this);\n        this.onToggle = this.onToggle.bind(this);\n    }\n\n    public componentDidUpdate(prevProps: ValueProps): void {\n        setTimeout(() => {\n            const { open, value, format, mode, allowValidation } = this.props;\n            const hasFocus = this.inputs.some(inp => inp === this.focused);\n            const allowTextSelection =\n                mode === 'day' || mode === 'month' || mode === 'year';\n\n            if (!hasFocus) {\n                if (open) {\n                    if (prevProps.value !== value && value) {\n                        const parts = splitDate(value, format);\n                        const input = this.inputs[0];\n\n                        this.inputs.forEach(\n                            (input, i) => (input.innerText = parts[i])\n                        );\n\n                        if (input && allowTextSelection) {\n                            input.focus();\n                        }\n                    }\n\n                    if (allowTextSelection) {\n                        if (!prevProps.open || value !== prevProps.value) {\n                            const [input] = this.inputs;\n\n                            if (input) {\n                                selectElement(input);\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (\n                open &&\n                prevProps.mode !== mode &&\n                !this.state.allSelected &&\n                allowTextSelection\n            ) {\n                const input = this.inputs.find(el => {\n                    const format = getAttribute(el, 'data-group');\n                    const type = getFormatType(format);\n\n                    return type === mode;\n                });\n\n                selectElement(input);\n            }\n\n            if (!open && value) {\n                const parts = splitDate(value, format);\n\n                this.inputs.forEach((input, i) => (input.innerText = parts[i]));\n            }\n\n            if (open && prevProps.value && !value && !allowValidation) {\n                this.inputs.forEach(input => (input.innerText = ''));\n            }\n\n            if (!open) {\n                this.setState({ allSelected: false });\n            }\n        }, 16);\n    }\n\n    public componentDidMount() {\n        if (this.props.value) {\n            this.forceUpdate();\n        }\n    }\n\n    public render(): React.ReactNode {\n        const {\n            placeholder,\n            value,\n            showDate,\n            showTime,\n            disabled,\n            open\n        } = this.props;\n        const ArrowButtonComp = this.props.arrowButtonComponent || ArrowButton;\n        const showPlaceholder = placeholder && !open;\n        const showClearer = value && !disabled;\n        const timeOnly = showTime && !showDate;\n\n        return (\n            <Container\n                data-role=\"value\"\n                className=\"react-slct-value react-timebomb-value\"\n                disabled={disabled}\n                onClick={this.onToggle}\n            >\n                <Flex>\n                    <Icon\n                        icon={this.icon}\n                        className={`react-timebomb-icon ${this.iconClass}`}\n                    />\n                    <Flex>\n                        {this.renderValue()}\n                        {showPlaceholder && (\n                            <Placeholder className=\"react-timebomb-placeholder\">\n                                {placeholder}\n                            </Placeholder>\n                        )}\n                    </Flex>\n                </Flex>\n                <Flex>\n                    {showClearer && (\n                        <ClearButton\n                            className=\"react-timebomb-clearer\"\n                            tabIndex={-1}\n                            onClick={this.onClear}\n                        >\n                            <ClearButtonX>×</ClearButtonX>\n                        </ClearButton>\n                    )}\n                    {!timeOnly && (\n                        <ArrowButtonComp disabled={disabled} open={open} />\n                    )}\n                </Flex>\n            </Container>\n        );\n    }\n\n    private renderValue(): React.ReactNode {\n        const { open, disabled, mobile, value } = this.props;\n        const contentEditable = !disabled && !mobile;\n\n        if (!open && !value) {\n            return null;\n        }\n\n        const formatGroups = this.formatGroups;\n\n        return (\n            <Flex>\n                {formatGroups.map((group, i) => {\n                    if (group.split('').some(g => formatSplitExpr.test(g))) {\n                        return null;\n                    } else {\n                        const separator = formatGroups[i + 1];\n\n                        return (\n                            <Input\n                                data-react-timebomb-selectable\n                                contentEditable={contentEditable}\n                                disabled={disabled}\n                                data-placeholder={group}\n                                data-separator={replaceSpaceWithNbsp(separator)}\n                                key={group}\n                                data-group={group}\n                                ref={this.onSearchRef}\n                                onKeyDown={this.onKeyDown}\n                                onKeyUp={this.onKeyUp}\n                                onFocus={this.onFocus}\n                                onBlur={this.onBlur}\n                                onClick={this.onClick}\n                                onDoubleClick={this.onDblClick}\n                                onChange={this.onChange}\n                            />\n                        );\n                    }\n                })}\n            </Flex>\n        );\n    }\n\n    private onSearchRef(el: HTMLSpanElement | null): void {\n        if (el) {\n            this.inputs.push(el);\n        } else {\n            this.inputs = [];\n        }\n    }\n\n    private onKeyDown(e: React.KeyboardEvent<HTMLSpanElement>): void {\n        const {\n            onChangeValueText,\n            format,\n            value,\n            allowValidation,\n            timeStep\n        } = this.props;\n        const input = e.currentTarget;\n        const { innerText, nextSibling, previousSibling } = input;\n        const formatGroup = getAttribute(input, 'data-group');\n        const numericFormat = formatIsActualNumber(formatGroup);\n        const sel = getSelection();\n        const hasSelection = Boolean(sel.focusOffset - sel.baseOffset);\n        let numericValue = parseInt(innerText, 10);\n\n        switch (e.keyCode) {\n            case keys.ENTER:\n            case keys.ESC:\n            case keys.BACKSPACE:\n            case keys.DOT:\n            case keys.COMMA:\n                e.preventDefault();\n                return;\n            case keys.ARROW_RIGHT:\n                e.preventDefault();\n\n                if (nextSibling instanceof HTMLSpanElement) {\n                    nextSibling.focus();\n                } else {\n                    selectElement(input);\n                }\n                return;\n            case keys.ARROW_LEFT:\n                e.preventDefault();\n\n                if (previousSibling instanceof HTMLSpanElement) {\n                    previousSibling.focus();\n                } else {\n                    selectElement(input);\n                }\n                return;\n            case keys.ARROW_UP:\n            case keys.ARROW_DOWN:\n                e.preventDefault();\n\n                if (!numericFormat) {\n                    return;\n                }\n\n                const isArrowUp = e.keyCode === keys.ARROW_UP;\n\n                if (isNaN(numericValue)) {\n                    numericValue = 0;\n                }\n\n                if (isFinite(numericValue)) {\n                    const formatType = getFormatType(formatGroup);\n\n                    if (!allowValidation) {\n                        const add = formatType === 'minute' ? timeStep || 1 : 1;\n                        const nextValue =\n                            numericValue + (isArrowUp ? add : -add);\n                        const valid = validateFormatGroup(\n                            nextValue,\n                            formatGroup\n                        );\n\n                        if (valid) {\n                            input.innerText =\n                                typeof valid === 'string'\n                                    ? valid\n                                    : formatNumber(nextValue);\n                        }\n                    } else {\n                        if (value && formatType) {\n                            const direction = isArrowUp ? 'add' : 'subtract';\n\n                            const newDate = manipulateDate(\n                                value,\n                                formatType,\n                                direction,\n                                timeStep\n                            );\n                            const enabled = isEnabled(\n                                'day',\n                                newDate,\n                                this.props\n                            );\n\n                            if (enabled) {\n                                const dateParts = splitDate(newDate, format);\n\n                                this.inputs.map(\n                                    (inp, i) => (inp.innerText = dateParts[i])\n                                );\n                            }\n                        }\n                    }\n\n                    selectElement(input);\n                    onChangeValueText(joinDates(this.inputs, format));\n                }\n                return;\n        }\n\n        const char = stringFromCharCode(e.keyCode);\n        const groupValue = innerText && !hasSelection ? innerText + char : char;\n\n        if (META_KEYS.includes(e.keyCode) || e.metaKey || e.ctrlKey) {\n            return;\n        }\n\n        if (!numericFormat) {\n            e.preventDefault();\n            return;\n        }\n\n        const valid = validateFormatGroup(groupValue, formatGroup);\n\n        if (!valid) {\n            e.preventDefault();\n        } else if (typeof valid === 'string') {\n            e.preventDefault();\n\n            input.innerText = valid;\n        }\n\n        if (\n            this.state.allSelected &&\n            e.keyCode !== keys.BACKSPACE &&\n            e.keyCode !== keys.DELETE\n        ) {\n            const [firstInput] = this.inputs;\n            let validatedChar = validateFormatGroup(char, formatGroup);\n\n            if (validatedChar && validatedChar === true) {\n                validatedChar = char;\n            }\n\n            if (validatedChar) {\n                e.preventDefault();\n\n                this.inputs.forEach((el, i) => i !== 0 && (el.innerText = ''));\n\n                if (validatedChar.length === 2) {\n                    selectElement(firstInput);\n                } else {\n                    clearSelection();\n\n                    firstInput.innerText = validatedChar;\n                    firstInput.focus();\n\n                    selectElement(firstInput, [1, 1]);\n                }\n            }\n        }\n\n        // validate group\n        if (!hasSelection && innerText.length >= formatGroup.length) {\n            e.preventDefault();\n        }\n    }\n\n    private onKeyUp(e: React.KeyboardEvent<HTMLSpanElement>): void {\n        const { onChangeValueText, format, onSubmit, onToggle } = this.props;\n        const input = e.currentTarget;\n        const { innerText, nextSibling, previousSibling } = input;\n\n        if (e.keyCode === keys.ENTER) {\n            e.preventDefault();\n\n            if (this.focused) {\n                this.focused.blur();\n            }\n            onSubmit();\n            return;\n        }\n\n        if (e.keyCode === keys.ESC) {\n            onToggle();\n            return;\n        }\n\n        if (this.state.allSelected) {\n            if (e.keyCode === keys.BACKSPACE || e.keyCode === keys.DELETE) {\n                // delete all\n                this.inputs.forEach(el => (el.innerText = ''));\n\n                selectElement(this.inputs[0]);\n            }\n\n            this.setState({ allSelected: false });\n        }\n\n        // remove text / focus prev\n        else if (e.keyCode === keys.BACKSPACE) {\n            if (innerText) {\n                input.innerText = '';\n            } else if (previousSibling instanceof HTMLSpanElement) {\n                selectElement(previousSibling);\n            }\n        }\n\n        // focus next\n        else if (\n            (innerText.length >= getAttribute(input, 'data-group').length &&\n                !FORBIDDEN_KEYS.includes(e.keyCode)) ||\n            e.keyCode === keys.DOT ||\n            e.keyCode === keys.COMMA\n        ) {\n            if (!nextSibling) {\n                selectElement(input);\n            } else if (nextSibling instanceof HTMLSpanElement) {\n                selectElement(nextSibling);\n            }\n\n            onChangeValueText(joinDates(this.inputs, format));\n        }\n    }\n\n    private onClick(e: React.SyntheticEvent<HTMLSpanElement>): void {\n        selectElement(e.currentTarget);\n    }\n\n    private onDblClick(e: React.SyntheticEvent<HTMLSpanElement>) {\n        const input = e.currentTarget;\n\n        if (input.parentNode && this.inputs.some(el => Boolean(el.innerText))) {\n            selectElement(this.inputs[0]);\n            selectElement(input.parentNode as HTMLElement);\n            this.setState({ allSelected: true }, this.props.onAllSelect);\n        }\n    }\n\n    private onFocus = (() => {\n        let timeout: NodeJS.Timeout;\n\n        return (e: React.SyntheticEvent<HTMLSpanElement>) => {\n            clearTimeout(timeout);\n\n            const input = e.currentTarget;\n\n            selectElement(input);\n\n            timeout = setTimeout(() => {\n                if (!this.state.allSelected) {\n                    const formatGroup = getAttribute(input, 'data-group');\n\n                    this.props.onChangeFormatGroup(formatGroup);\n                }\n            }, 16);\n        };\n    })();\n\n    private onBlur(e: React.SyntheticEvent<HTMLSpanElement>): void {\n        if (!this.state.allSelected) {\n            const input = e.target as HTMLSpanElement;\n            const value = input.innerText;\n            const dataGroup = getAttribute(input, 'data-group');\n            const formatType = getFormatType(dataGroup);\n\n            if (formatType) {\n                const filledValue = fillZero(value, formatType);\n\n                if (filledValue) {\n                    input.innerText = filledValue;\n                }\n            }\n        }\n\n        // check if timebomb is still focused\n        setTimeout(() => {\n            const { focused } = this;\n\n            if (\n                this.props.open &&\n                focused &&\n                !getAttribute(focused, 'data-react-timebomb-selectable')\n            ) {\n                this.props.onToggle();\n            }\n        }, 0);\n    }\n\n    private onChange(e: React.KeyboardEvent<HTMLSpanElement>): void {\n        const { format, onChangeValueText } = this.props;\n        const input = e.currentTarget;\n        const { innerText, nextSibling } = input;\n\n        onChangeValueText(joinDates(this.inputs, format));\n\n        if (innerText.length >= getAttribute(input, 'data-group').length) {\n            if (nextSibling instanceof HTMLSpanElement) {\n                nextSibling.focus();\n            }\n        }\n    }\n\n    private onClear(e: React.MouseEvent<HTMLButtonElement>): void {\n        e.stopPropagation();\n\n        this.props.onClear();\n    }\n\n    private onToggle(e: React.SyntheticEvent<HTMLSpanElement>): void {\n        const { open, disabled, onToggle } = this.props;\n\n        if (disabled) {\n            return;\n        }\n\n        if (!this.inputs.some(inp => inp === e.target) || !open) {\n            onToggle();\n        }\n    }\n}\n"]}